<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Write-On (Simple)</title>
  <style>
    :root { --bg:#0b1220; --panel:#111a2e; --line:#26324d; --text:#e8eefc; --muted:#a9b7d6; --btn:#2b6cff; --danger:#e04040; }
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); }
    header { display:flex; gap:12px; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line); background:#0a1020; position:sticky; top:0; z-index:10; }
    header .group { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    header .spacer { flex:1; }
    button { border:0; border-radius:8px; padding:8px 10px; background:var(--btn); color:white; cursor:pointer; font-weight:600; }
    button.secondary { background:#1f2a44; color:var(--text); border:1px solid var(--line); }
    button.danger { background:var(--danger); }
    button:disabled { opacity:.55; cursor:not-allowed; }
    input[type="file"] { color:var(--muted); }
    input[type="text"], textarea, select { width:100%; box-sizing:border-box; border-radius:8px; border:1px solid var(--line); background:#0a1020; color:var(--text); padding:8px 10px; }
    textarea { min-height:80px; resize:vertical; }
    .wrap { display:grid; grid-template-columns: 1fr 340px; gap:12px; padding:12px; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }

    .stage {
      background:#0a1020;
      border:1px solid var(--line);
      border-radius:12px;
      overflow:auto;
      padding:12px;
      min-height: 60vh;
    }
    .canvasStack { position:relative; display:inline-block; }
    canvas { display:block; }

    .side {
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      height: fit-content;
      position:sticky;
      top:64px;
    }
    .side h3 { margin:0 0 10px 0; font-size:14px; color:var(--muted); letter-spacing:.02em; text-transform:uppercase; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .label { font-size:12px; color:var(--muted); margin:10px 0 6px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--line); background:#0a1020; border-radius:999px; color:var(--muted); font-size:12px; }
    .list { margin-top:10px; border-top:1px solid var(--line); padding-top:10px; }
    .item {
      border:1px solid var(--line);
      background:#0a1020;
      border-radius:10px;
      padding:8px;
      margin-bottom:8px;
      cursor:pointer;
    }
    .item b { display:block; font-size:13px; color:var(--text); }
    .item small { color:var(--muted); }
    .banner {
      display:none;
      margin:12px;
      padding:10px 12px;
      border:1px solid #6b2f2f;
      background:#2a0f12;
      border-radius:10px;
      color:#ffd7d7;
    }
    .banner.show { display:block; }
    .hint { font-size:12px; color:var(--muted); line-height:1.35; }
    kbd { background:#0a1020; border:1px solid var(--line); border-bottom-width:2px; padding:1px 6px; border-radius:6px; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <input id="file" type="file" accept="application/pdf" />
      <button id="export" class="secondary" disabled>Download Updated PDF</button>
    </div>

    <div class="group">
      <button id="prev" class="secondary" disabled>Prev</button>
      <span class="pill">Page <span id="pageNum">–</span> / <span id="pageCount">–</span></span>
      <button id="next" class="secondary" disabled>Next</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <button id="toolSelect" class="secondary">Select/Move</button>
      <button id="toolAdd" class="">Add Field</button>
      <button id="del" class="danger" disabled>Delete</button>
    </div>
  </header>

  <div id="banner" class="banner"></div>

  <div class="wrap">
    <div class="stage">
      <div class="canvasStack" id="stack">
        <canvas id="pdfCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
      </div>
    </div>

    <div class="side">
      <h3>Selected Field</h3>

      <div class="hint">
        Tool: <span id="toolName" class="pill" style="display:inline-flex; padding:4px 10px;">Select/Move</span><br/>
        Tips: click “Add Field”, then click on the page to place it.
        Use <kbd>Del</kbd> to delete selected.
      </div>

      <div class="label">Label</div>
      <input id="fieldLabel" type="text" placeholder="e.g., Patient Name" disabled />

      <div class="label">Value</div>
      <textarea id="fieldValue" placeholder="Type what you want written onto the PDF..." disabled></textarea>

      <div class="row" style="margin-top:10px;">
        <button id="apply" class="secondary" disabled>Apply Text</button>
        <button id="delete2" class="danger" disabled>Delete</button>
      </div>

      <div class="list">
        <h3>Fields on Page</h3>
        <div id="fieldList" class="hint">Load a PDF and add a field.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- robust script loading (fixes pdfjsLib undefined) ----------
  const banner = document.getElementById('banner');

  function showBanner(html) {
    banner.innerHTML = html;
    banner.classList.add('show');
  }

  function loadScript(url) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => reject(new Error('Failed to load: ' + url));
      document.head.appendChild(s);
    });
  }

  async function loadAny(candidates, testFn) {
    let lastErr = null;
    for (const url of candidates) {
      try {
        await loadScript(url);
        if (testFn()) return url;
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('All candidates failed.');
  }

  // Paired PDF.js lib + worker URLs
  const PDFJS_CANDIDATES = [
    {
      lib: "https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js",
      worker: "https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js"
    },
    {
      lib: "https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js",
      worker: "https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js"
    },
    {
      lib: "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js",
      worker: "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"
    },
    {
      lib: "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js",
      worker: "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js"
    }
  ];

  const FABRIC_CANDIDATES = [
    "https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js",
    "https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"
  ];

  const PDFLIB_CANDIDATES = [
    "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js",
    "https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"
  ];

  async function loadPdfJsWithWorker() {
    let lastErr = null;
    for (const c of PDFJS_CANDIDATES) {
      try {
        await loadScript(c.lib);
        if (!window.pdfjsLib) throw new Error("pdfjsLib global not created");
        // Worker URL must match lib version when possible
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.worker;
        return c;
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error("Failed to load PDF.js");
  }

  async function ensureLibs() {
    try {
      await loadAny(FABRIC_CANDIDATES, () => !!window.fabric);
      await loadAny(PDFLIB_CANDIDATES, () => !!window.PDFLib);
      await loadPdfJsWithWorker();
    } catch (e) {
      showBanner(`
        <b>Couldn’t load required libraries.</b><br/>
        This usually means your network is blocking CDNs or you’re offline.<br/>
        Error: <code>${String(e.message || e)}</code><br/><br/>
        Fix: try a different network, or download these files and serve locally:
        <ul>
          <li>PDF.js <code>pdf.min.js</code> + <code>pdf.worker.min.js</code></li>
          <li>Fabric.js <code>fabric.min.js</code></li>
          <li>pdf-lib <code>pdf-lib.min.js</code></li>
        </ul>
      `);
      throw e;
    }
  }

  // ---------- app state ----------
  const fileEl = document.getElementById('file');
  const exportBtn = document.getElementById('export');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const pageNumEl = document.getElementById('pageNum');
  const pageCountEl = document.getElementById('pageCount');

  const toolSelectBtn = document.getElementById('toolSelect');
  const toolAddBtn = document.getElementById('toolAdd');
  const delBtn = document.getElementById('del');

  const toolNameEl = document.getElementById('toolName');
  const fieldLabelEl = document.getElementById('fieldLabel');
  const fieldValueEl = document.getElementById('fieldValue');
  const applyBtn = document.getElementById('apply');
  const delete2Btn = document.getElementById('delete2');
  const fieldListEl = document.getElementById('fieldList');

  const pdfCanvas = document.getElementById('pdfCanvas');
  const drawCanvas = document.getElementById('drawCanvas');
  const stack = document.getElementById('stack');
  const pdfCtx = pdfCanvas.getContext('2d');

  const state = {
    pdfBytes: null,
    pdfDoc: null,
    fileNameBase: "annotated",
    page: 1,
    pageCount: 0,
    viewScale: 1.35,
    tool: "select", // 'select' | 'add'
    fabricCanvas: null,
    pageStates: {} // pageNumber -> { json, w, h }
  };

  function setTool(tool) {
    state.tool = tool;
    toolNameEl.textContent = tool === "add" ? "Add Field" : "Select/Move";
    toolAddBtn.classList.toggle('secondary', tool !== "add");
    toolSelectBtn.classList.toggle('secondary', tool !== "select");
    if (state.fabricCanvas) {
      state.fabricCanvas.isDrawingMode = false; // keep simple
      state.fabricCanvas.selection = (tool === "select");
      state.fabricCanvas.defaultCursor = (tool === "add") ? "crosshair" : "default";
    }
  }

  function enableFieldEditor(enabled) {
    fieldLabelEl.disabled = !enabled;
    fieldValueEl.disabled = !enabled;
    applyBtn.disabled = !enabled;
    delete2Btn.disabled = !enabled;
  }

  function setDeleteEnabled(enabled) {
    delBtn.disabled = !enabled;
    delete2Btn.disabled = !enabled;
  }

  function safeBaseName(name) {
    return (name || "annotated")
      .replace(/\.pdf$/i, "")
      .replace(/[^\w\-]+/g, "_")
      .replace(/_+/g, "_")
      .slice(0, 80) || "annotated";
  }

  function saveCurrentPageState() {
    if (!state.fabricCanvas) return;
    const pageNo = state.page;
    const json = state.fabricCanvas.toJSON(["data"]);
    state.pageStates[pageNo] = { json, w: state.fabricCanvas.getWidth(), h: state.fabricCanvas.getHeight() };
  }

  function scaleObjectsToCanvas(fcanvas, sx, sy) {
    fcanvas.getObjects().forEach(obj => {
      obj.set({
        left: obj.left * sx,
        top: obj.top * sy,
        scaleX: obj.scaleX * sx,
        scaleY: obj.scaleY * sy
      });
      obj.setCoords();
    });
    fcanvas.requestRenderAll();
  }

  function clearSelectionUI() {
    enableFieldEditor(false);
    fieldLabelEl.value = "";
    fieldValueEl.value = "";
    setDeleteEnabled(false);
  }

  function getSelectedFieldGroup() {
    if (!state.fabricCanvas) return null;
    const obj = state.fabricCanvas.getActiveObject();
    if (!obj) return null;
    if (obj.type === "activeSelection") return null;
    if (obj.data && obj.data.type === "field") return obj;
    return null;
  }

  function refreshFieldList() {
    if (!state.fabricCanvas) {
      fieldListEl.textContent = "Load a PDF and add a field.";
      return;
    }
    const fields = state.fabricCanvas.getObjects().filter(o => o.data && o.data.type === "field");
    if (!fields.length) {
      fieldListEl.innerHTML = `<div class="hint">No fields on this page yet.</div>`;
      return;
    }
    fieldListEl.innerHTML = "";
    fields.forEach(f => {
      const div = document.createElement('div');
      div.className = 'item';
      const label = (f.data.label || "Field").trim() || "Field";
      div.innerHTML = `<b>${escapeHtml(label)}</b><small>${escapeHtml(f.data.id || "")}</small>`;
      div.addEventListener('click', () => {
        state.fabricCanvas.setActiveObject(f);
        state.fabricCanvas.requestRenderAll();
        syncSelectionUI();
      });
      fieldListEl.appendChild(div);
    });
  }

  function escapeHtml(s) {
    return String(s || "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }

  function syncSelectionUI() {
    const group = getSelectedFieldGroup();
    if (!group) {
      clearSelectionUI();
      return;
    }
    enableFieldEditor(true);
    fieldLabelEl.value = group.data.label || "";
    fieldValueEl.value = group.data.value || "";
    setDeleteEnabled(true);
  }

  function createFieldAt(x, y) {
    const fabric = window.fabric;

    const id = "field_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 7);
    const labelText = new fabric.Text("Label", {
      left: 0, top: -16, fontSize: 12, fill: "#111",
      backgroundColor: "rgba(255,255,255,0.85)",
      padding: 2
    });

    const rect = new fabric.Rect({
      left: 0, top: 0, width: 220, height: 60,
      rx: 6, ry: 6,
      fill: "rgba(255, 215, 64, 0.18)",
      stroke: "#ffcc33",
      strokeWidth: 2
    });

    const valueText = new fabric.Textbox("", {
      left: 8, top: 8,
      width: 204,
      fontSize: 14,
      fill: "#111"
    });

    const group = new fabric.Group([rect, valueText, labelText], {
      left: x, top: y,
      originX: "left", originY: "top",
      cornerStyle: "circle",
      transparentCorners: false,
      padding: 2
    });

    group.data = { type: "field", id, label: "Label", value: "" };

    state.fabricCanvas.add(group);
    state.fabricCanvas.setActiveObject(group);
    state.fabricCanvas.requestRenderAll();
    refreshFieldList();
    syncSelectionUI();
  }

  async function renderPage(pageNo) {
    const pdfjsLib = window.pdfjsLib;
    if (!state.pdfDoc) return;

    // Save previous page overlay
    saveCurrentPageState();

    state.page = pageNo;
    pageNumEl.textContent = String(state.page);
    pageCountEl.textContent = String(state.pageCount);
    prevBtn.disabled = (state.page <= 1);
    nextBtn.disabled = (state.page >= state.pageCount);

    const page = await state.pdfDoc.getPage(pageNo);
    const viewport = page.getViewport({ scale: state.viewScale });

    // PDF background canvas
    pdfCanvas.width = Math.floor(viewport.width);
    pdfCanvas.height = Math.floor(viewport.height);

    // Overlay canvas (fabric)
    drawCanvas.width = pdfCanvas.width;
    drawCanvas.height = pdfCanvas.height;

    // Keep stack sized to content
    stack.style.width = pdfCanvas.width + "px";
    stack.style.height = pdfCanvas.height + "px";
    drawCanvas.style.position = "absolute";
    drawCanvas.style.left = "0";
    drawCanvas.style.top = "0";

    await page.render({ canvasContext: pdfCtx, viewport }).promise;

    const fabric = window.fabric;
    if (!state.fabricCanvas) {
      state.fabricCanvas = new fabric.Canvas(drawCanvas, {
        preserveObjectStacking: true,
        selection: true
      });

      // click-to-add
      state.fabricCanvas.on("mouse:down", (opt) => {
        if (state.tool !== "add") return;
        // don't add if clicking an existing object
        if (opt.target) return;
        const p = state.fabricCanvas.getPointer(opt.e);
        createFieldAt(p.x, p.y);
        setTool("select");
      });

      // selection hooks
      state.fabricCanvas.on("selection:created", syncSelectionUI);
      state.fabricCanvas.on("selection:updated", syncSelectionUI);
      state.fabricCanvas.on("selection:cleared", () => { clearSelectionUI(); });

      // keyboard delete
      window.addEventListener("keydown", (e) => {
        if (e.key === "Delete" || e.key === "Backspace") {
          const active = state.fabricCanvas.getActiveObject();
          if (active) {
            e.preventDefault();
            deleteSelected();
          }
        }
      });
    } else {
      // resize existing fabric canvas
      const oldW = state.fabricCanvas.getWidth();
      const oldH = state.fabricCanvas.getHeight();
      state.fabricCanvas.setWidth(drawCanvas.width);
      state.fabricCanvas.setHeight(drawCanvas.height);
      // if we resized, we’ll scale restored objects when loading state below
      state.fabricCanvas.requestRenderAll();
      // (no scaling here; we do it when restoring)
    }

    // restore overlay for this page (if any)
    state.fabricCanvas.clear();

    const saved = state.pageStates[pageNo];
    if (saved && saved.json) {
      const oldW = saved.w || drawCanvas.width;
      const oldH = saved.h || drawCanvas.height;
      await new Promise((resolve) => {
        state.fabricCanvas.loadFromJSON(saved.json, () => resolve());
      });
      // scale if canvas size differs
      const sx = drawCanvas.width / oldW;
      const sy = drawCanvas.height / oldH;
      if (Math.abs(sx - 1) > 0.001 || Math.abs(sy - 1) > 0.001) {
        scaleObjectsToCanvas(state.fabricCanvas, sx, sy);
      }
      state.fabricCanvas.requestRenderAll();
    }

    setTool(state.tool); // ensure correct cursor/selection mode
    refreshFieldList();
    clearSelectionUI();
  }

  function deleteSelected() {
    if (!state.fabricCanvas) return;
    const active = state.fabricCanvas.getActiveObject();
    if (!active) return;

    if (active.type === "activeSelection") {
      active.getObjects().forEach(obj => state.fabricCanvas.remove(obj));
      state.fabricCanvas.discardActiveObject();
    } else {
      state.fabricCanvas.remove(active);
      state.fabricCanvas.discardActiveObject();
    }
    state.fabricCanvas.requestRenderAll();
    refreshFieldList();
    clearSelectionUI();
  }

  function applyTextToSelected() {
    const group = getSelectedFieldGroup();
    if (!group) return;

    const newLabel = (fieldLabelEl.value || "").trim();
    const newValue = (fieldValueEl.value || "");

    // group objects: [rect, valueText, labelText]
    const objs = group.getObjects();
    const rect = objs[0];
    const valueText = objs[1];
    const labelText = objs[2];

    group.data.label = newLabel;
    group.data.value = newValue;

    labelText.set("text", newLabel || "Label");
    valueText.set("text", newValue || "");

    // expand rect height a bit if multi-line
    const lines = String(newValue).split("\n").length;
    const newH = Math.max(60, 24 + lines * 18);
    rect.set("height", newH);
    valueText.set("height", newH - 16);

    group._calcBounds();
    group._updateObjectsCoords();
    group.setCoords();

    state.fabricCanvas.requestRenderAll();
    refreshFieldList();
  }

  async function exportAnnotatedPdf() {
    if (!state.pdfBytes || !state.pdfDoc) return;

    saveCurrentPageState();

    const pdfjsLib = window.pdfjsLib;
    const { PDFDocument } = window.PDFLib;

    const origPdf = await PDFDocument.load(state.pdfBytes);
    const outPdf = await PDFDocument.create();
    const origPages = origPdf.getPages();

    const EXPORT_SCALE = 2.0; // higher = sharper output (slower)

    for (let i = 1; i <= state.pageCount; i++) {
      // render PDF page background via pdf.js
      const page = await state.pdfDoc.getPage(i);
      const viewport = page.getViewport({ scale: EXPORT_SCALE });

      const bg = document.createElement("canvas");
      bg.width = Math.floor(viewport.width);
      bg.height = Math.floor(viewport.height);
      const bgCtx = bg.getContext("2d");

      await page.render({ canvasContext: bgCtx, viewport }).promise;

      // render overlay via fabric static canvas, scaled up
      const overlay = new window.fabric.StaticCanvas(null, { width: bg.width, height: bg.height });

      const saved = state.pageStates[i];
      if (saved && saved.json) {
        await new Promise((resolve) => overlay.loadFromJSON(saved.json, () => resolve()));

        const sx = bg.width / (saved.w || bg.width);
        const sy = bg.height / (saved.h || bg.height);
        if (Math.abs(sx - 1) > 0.001 || Math.abs(sy - 1) > 0.001) {
          overlay.getObjects().forEach(obj => {
            obj.set({
              left: obj.left * sx,
              top: obj.top * sy,
              scaleX: obj.scaleX * sx,
              scaleY: obj.scaleY * sy
            });
            obj.setCoords();
          });
          overlay.requestRenderAll();
        }
      }

      // composite overlay onto background
      const overlayEl = overlay.getElement();
      bgCtx.drawImage(overlayEl, 0, 0);

      // convert composite to PNG bytes
      const dataUrl = bg.toDataURL("image/png");
      const pngBytes = await (await fetch(dataUrl)).arrayBuffer();

      // new page in output PDF with same size as original page
      const srcPage = origPages[i - 1];
      const { width, height } = srcPage.getSize();

      const outPage = outPdf.addPage([width, height]);
      const embedded = await outPdf.embedPng(pngBytes);

      outPage.drawImage(embedded, { x: 0, y: 0, width, height });
    }

    const outBytes = await outPdf.save();
    const blob = new Blob([outBytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = state.fileNameBase + "_updated.pdf";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---------- UI wiring ----------
  fileEl.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    const bytes = await f.arrayBuffer();
    state.pdfBytes = bytes;
    state.fileNameBase = safeBaseName(f.name);

    const pdfjsLib = window.pdfjsLib;
    const loadingTask = pdfjsLib.getDocument({ data: new Uint8Array(bytes) });
    state.pdfDoc = await loadingTask.promise;

    state.pageCount = state.pdfDoc.numPages;
    state.page = 1;

    pageCountEl.textContent = String(state.pageCount);
    pageNumEl.textContent = "1";

    prevBtn.disabled = true;
    nextBtn.disabled = (state.pageCount <= 1);

    exportBtn.disabled = false;

    // reset overlays
    state.pageStates = {};
    if (state.fabricCanvas) state.fabricCanvas.clear();
    clearSelectionUI();
    refreshFieldList();

    await renderPage(1);

    showBanner(""); banner.classList.remove('show');
  });

  prevBtn.addEventListener('click', async () => {
    if (!state.pdfDoc || state.page <= 1) return;
    await renderPage(state.page - 1);
  });
  nextBtn.addEventListener('click', async () => {
    if (!state.pdfDoc || state.page >= state.pageCount) return;
    await renderPage(state.page + 1);
  });

  toolSelectBtn.addEventListener('click', () => setTool("select"));
  toolAddBtn.addEventListener('click', () => setTool("add"));

  delBtn.addEventListener('click', deleteSelected);
  delete2Btn.addEventListener('click', deleteSelected);
  applyBtn.addEventListener('click', applyTextToSelected);

  exportBtn.addEventListener('click', async () => {
    exportBtn.disabled = true;
    exportBtn.textContent = "Building PDF...";
    try {
      await exportAnnotatedPdf();
    } catch (err) {
      console.error(err);
      showBanner(`<b>Export failed.</b><br/><code>${escapeHtml(String(err && err.message ? err.message : err))}</code>`);
    } finally {
      exportBtn.textContent = "Download Updated PDF";
      exportBtn.disabled = false;
    }
  });

  // Keep delete/apply enabled only when a field is selected
  fieldLabelEl.addEventListener('input', () => {});
  fieldValueEl.addEventListener('input', () => {});

  // ---------- boot ----------
  (async () => {
    await ensureLibs();
    // now safe to reference window.pdfjsLib etc
    setTool("select");
  })();
})();
</script>
</body>
</html>
