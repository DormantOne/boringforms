<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Write-On (Boxes + Side Editor)</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#111a2e; --line:#26324d; --text:#e8eefc; --muted:#a9b7d6;
      --btn:#2b6cff; --danger:#e04040; --ok:#22c55e;
      --boxBorder: rgba(255,255,255,0.30);
      --boxFill: rgba(255,255,255,0.06);
      --boxBorderSel: rgba(34,197,94,0.92);
      --boxFillSel: rgba(34,197,94,0.12);
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); }
    header{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; border-bottom:1px solid var(--line); background:#0a1020;
      position:sticky; top:0; z-index:50;
    }
    .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .spacer{ flex:1; }
    button{
      border:0; border-radius:10px; padding:8px 10px; background:var(--btn); color:white;
      cursor:pointer; font-weight:800;
    }
    button.secondary{ background:#1f2a44; color:var(--text); border:1px solid var(--line); }
    button.danger{ background:var(--danger); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    input[type="file"]{ color:var(--muted); }
    input[type="text"], textarea{
      width:100%; box-sizing:border-box; border-radius:10px; border:1px solid var(--line);
      background:#0a1020; color:var(--text); padding:8px 10px;
    }
    textarea{ min-height:120px; resize:vertical; line-height:1.25; }

    .wrap{ display:grid; grid-template-columns: 1fr 360px; gap:12px; padding:12px; }
    @media (max-width: 980px){ .wrap{ grid-template-columns:1fr; } .side{ position:static !important; } }

    .stage{
      background:#0a1020; border:1px solid var(--line); border-radius:14px;
      overflow:auto; padding:12px; min-height:65vh;
    }
    .stack{ position:relative; display:inline-block; }
    #pdfCanvas{ display:block; background:#0a1020; }

    #overlay{
      position:absolute; left:0; top:0; right:0; bottom:0;
      pointer-events:auto;
    }

    /* drag-to-create marquee */
    #marquee{
      position:absolute; border:2px dashed rgba(255,255,255,0.75);
      background: rgba(255,255,255,0.08);
      display:none; pointer-events:none;
      border-radius:10px;
    }

    /* Field box (minimal) */
    .field{
      position:absolute;
      border:1px solid var(--boxBorder);
      background: var(--boxFill);
      border-radius:10px;
      box-sizing:border-box;
      cursor:pointer;
      user-select:none;
    }
    .field.selected{
      border:2px solid var(--boxBorderSel);
      background: var(--boxFillSel);
      cursor: grab;
    }
    .field.selected:active{ cursor: grabbing; }

    .badge{
      position:absolute; top:6px; left:6px;
      width:20px; height:20px; border-radius:999px;
      display:grid; place-items:center;
      background: rgba(10,16,32,0.85);
      border:1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      font-size:12px;
      font-weight:900;
      pointer-events:none;
    }
    .ghost{
      position:absolute; left:32px; top:7px; right:8px;
      font-size:12px;
      color: rgba(255,255,255,0.55);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      pointer-events:none;
    }

    /* subtle resize handle (only when selected) */
    .resizer{
      position:absolute; right:4px; bottom:4px;
      width:14px; height:14px; border-radius:6px;
      background: rgba(255,255,255,0.16);
      border:1px solid rgba(255,255,255,0.18);
      display:none;
      cursor: se-resize;
    }
    .field.selected .resizer{ display:block; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border:1px solid var(--line); background:#0a1020;
      border-radius:999px; color:var(--muted); font-size:12px;
    }

    .banner{
      display:none; margin:12px; padding:10px 12px; border:1px solid #6b2f2f; background:#2a0f12;
      border-radius:12px; color:#ffd7d7;
    }
    .banner.show{ display:block; }

    .side{
      background:var(--panel); border:1px solid var(--line); border-radius:14px;
      padding:12px; height:fit-content; position:sticky; top:68px;
    }
    .side h3{ margin:0 0 10px; font-size:14px; color:var(--muted); letter-spacing:.02em; text-transform:uppercase; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.35; }
    .label{ font-size:12px; color:var(--muted); margin:10px 0 6px; }
    .row{ display:flex; gap:8px; align-items:center; }
    .k{ font-weight:900; color:var(--text); }
    .kv{ color:var(--muted); font-size:12px; }

    .list{
      margin-top:12px;
      border-top:1px solid var(--line);
      padding-top:12px;
    }
    .item{
      border:1px solid var(--line); background:#0a1020; border-radius:12px;
      padding:8px; margin-bottom:8px; cursor:pointer;
    }
    .item.active{
      border-color: rgba(34,197,94,0.55);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.10);
    }
    .item b{ display:block; font-size:13px; color:var(--text); }
    .item small{ color:var(--muted); }
    code{ color:#ffe3a3; }
  </style>
</head>

<body>
  <header>
    <div class="group">
      <input id="file" type="file" accept="application/pdf" />
      <button id="export" class="secondary" disabled>Download Updated PDF</button>
    </div>

    <div class="group">
      <button id="prev" class="secondary" disabled>Prev</button>
      <span class="pill">Page <span id="pageNum">–</span> / <span id="pageCount">–</span></span>
      <button id="next" class="secondary" disabled>Next</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <span class="pill">Drag to add a box • Click to select • Drag selected to move</span>
    </div>
  </header>

  <div id="banner" class="banner"></div>

  <div class="wrap">
    <div class="stage">
      <div class="stack" id="stack">
        <canvas id="pdfCanvas"></canvas>
        <div id="overlay">
          <div id="marquee"></div>
        </div>
      </div>
    </div>

    <div class="side">
      <h3>Selected Field</h3>

      <div id="noSel" class="hint">
        Load a PDF, then <b>drag</b> on the page to draw a box.<br/>
        Click a box to select it. The box shows a small badge like <code>A</code>.
      </div>

      <div id="selUI" style="display:none;">
        <div class="row" style="justify-content:space-between;">
          <div>
            <div class="kv">Badge</div>
            <div class="k" id="selTag">–</div>
          </div>
          <div style="text-align:right;">
            <div class="kv">Field ID</div>
            <div class="k" style="font-size:12px;" id="selId">–</div>
          </div>
        </div>

        <div class="label">Name (what this field is)</div>
        <input id="selLabel" type="text" placeholder="e.g., Patient name" />

        <div class="label">Value (what you want written into the PDF)</div>
        <textarea id="selValue" placeholder="Type the value here..."></textarea>

        <div class="row" style="margin-top:10px;">
          <button id="deleteSel" class="danger" disabled>Delete</button>
          <button id="clearSel" class="secondary" disabled>Clear Text</button>
        </div>

        <div class="hint" style="margin-top:10px;">
          Tip: the box stays unobtrusive — the writing happens here on the side, and gets flattened into the PDF on export.
        </div>
      </div>

      <div class="list">
        <h3>Fields on this page</h3>
        <div id="fieldList" class="hint">Load a PDF and draw a box.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const banner = document.getElementById('banner');
  const fileEl = document.getElementById('file');
  const exportBtn = document.getElementById('export');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const pageNumEl = document.getElementById('pageNum');
  const pageCountEl = document.getElementById('pageCount');

  const pdfCanvas = document.getElementById('pdfCanvas');
  const pdfCtx = pdfCanvas.getContext('2d');
  const stack = document.getElementById('stack');
  const overlay = document.getElementById('overlay');
  const marquee = document.getElementById('marquee');
  const fieldListEl = document.getElementById('fieldList');

  const noSel = document.getElementById('noSel');
  const selUI = document.getElementById('selUI');
  const selTagEl = document.getElementById('selTag');
  const selIdEl = document.getElementById('selId');
  const selLabelEl = document.getElementById('selLabel');
  const selValueEl = document.getElementById('selValue');
  const deleteSelBtn = document.getElementById('deleteSel');
  const clearSelBtn = document.getElementById('clearSel');

  function showBanner(html) {
    if (!html) { banner.classList.remove('show'); banner.innerHTML = ""; return; }
    banner.innerHTML = html;
    banner.classList.add('show');
  }
  function escapeHtml(s){
    return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }

  // ---- robust CDN loading (prevents pdfjsLib undefined) ----
  function loadScript(url){
    return new Promise((resolve,reject)=>{
      const s=document.createElement('script');
      s.src=url; s.async=true;
      s.onload=()=>resolve(url);
      s.onerror=()=>reject(new Error("Failed to load: " + url));
      document.head.appendChild(s);
    });
  }

  async function loadPdfJs() {
    const candidates = [
      { lib:"https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js", worker:"https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js" },
      { lib:"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js", worker:"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js" },
      { lib:"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js", worker:"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js" },
      { lib:"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js", worker:"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js" },
    ];
    let lastErr=null;
    for (const c of candidates){
      try{
        await loadScript(c.lib);
        if (!window.pdfjsLib) throw new Error("pdfjsLib global not created");
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.worker;
        return;
      }catch(e){ lastErr=e; }
    }
    throw lastErr || new Error("Failed to load PDF.js");
  }

  async function loadPdfLib() {
    const candidates = [
      "https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js",
      "https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"
    ];
    let lastErr=null;
    for (const url of candidates){
      try{
        await loadScript(url);
        if (!window.PDFLib) throw new Error("PDFLib global not created");
        return;
      }catch(e){ lastErr=e; }
    }
    throw lastErr || new Error("Failed to load pdf-lib");
  }

  // ---- State ----
  const state = {
    pdfBytes: null,
    pdfDoc: null,          // pdf.js doc
    pageCount: 0,
    page: 1,
    viewScale: 1.35,
    baseName: "updated",
    selectedId: null,
    tagCounter: 0,         // for A, B, C...
    // pages[pageNumber] = [{id,tag,label,value,x,y,w,h}] normalized to current rendered canvas (0..1)
    pages: {}
  };

  function safeBaseName(name){
    return (name || "updated")
      .replace(/\.pdf$/i,"")
      .replace(/[^\w\-]+/g,"_")
      .replace(/_+/g,"_")
      .slice(0,80) || "updated";
  }

  function indexToTag(i){
    // 0->A ... 25->Z, 26->AA, 27->AB ...
    let n = i + 1;
    let s = "";
    while (n > 0){
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function getPageFields(pageNo){
    if (!state.pages[pageNo]) state.pages[pageNo] = [];
    return state.pages[pageNo];
  }
  function getFieldById(id){
    const fields = getPageFields(state.page);
    return fields.find(f => f.id === id) || null;
  }

  function setSelected(id){
    state.selectedId = id;

    overlay.querySelectorAll('.field').forEach(el=>{
      el.classList.toggle('selected', el.dataset.id === id);
    });
    overlay.querySelectorAll('.item').forEach(el=>{
      el.classList.toggle('active', el.dataset.id === id);
    });

    const f = id ? getFieldById(id) : null;
    const has = !!f;

    noSel.style.display = has ? "none" : "block";
    selUI.style.display = has ? "block" : "none";
    deleteSelBtn.disabled = !has;
    clearSelBtn.disabled = !has;
    selLabelEl.disabled = !has;
    selValueEl.disabled = !has;

    if (has){
      selTagEl.textContent = f.tag;
      selIdEl.textContent = f.id;
      selLabelEl.value = f.label || "";
      selValueEl.value = f.value || "";
    }
  }

  function clearOverlayFields(){
    overlay.querySelectorAll('.field').forEach(el=>el.remove());
    setSelected(null);
  }

  function pxToNorm(rectPx){
    const W = pdfCanvas.width, H = pdfCanvas.height;
    return { x: rectPx.x / W, y: rectPx.y / H, w: rectPx.w / W, h: rectPx.h / H };
  }

  function normToPx(n){
    const W = pdfCanvas.width, H = pdfCanvas.height;
    return { x: n.x * W, y: n.y * H, w: n.w * W, h: n.h * H };
  }

  function clampFieldPx(p){
    const W = pdfCanvas.width, H = pdfCanvas.height;
    p.w = Math.max(40, Math.min(p.w, W));
    p.h = Math.max(26, Math.min(p.h, H));
    p.x = Math.max(0, Math.min(p.x, W - p.w));
    p.y = Math.max(0, Math.min(p.y, H - p.h));
    return p;
  }

  function refreshFieldList(){
    const fields = getPageFields(state.page);
    if (!fields.length){
      fieldListEl.innerHTML = `<div class="hint">No fields on this page yet. Drag to create one.</div>`;
      return;
    }
    fieldListEl.innerHTML = "";
    for (const f of fields){
      const div = document.createElement('div');
      div.className = 'item';
      div.dataset.id = f.id;
      div.innerHTML = `<b>${escapeHtml(f.tag)} — ${escapeHtml(f.label || "(unnamed)")}</b><small>${escapeHtml(f.id)}</small>`;
      div.addEventListener('click', ()=>{
        setSelected(f.id);
        const el = overlay.querySelector(`.field[data-id="${CSS.escape(f.id)}"]`);
        if (el) el.scrollIntoView({block:"nearest", inline:"nearest"});
      });
      fieldListEl.appendChild(div);
    }
    // reapply active style
    overlay.querySelectorAll('.item').forEach(el=>{
      el.classList.toggle('active', el.dataset.id === state.selectedId);
    });
  }

  function updateFieldDomGhost(el, field){
    const ghost = el.querySelector('.ghost');
    const name = (field.label || "").trim();
    const val = (field.value || "").trim();
    const snippet = val ? val.split(/\r?\n/)[0].slice(0, 60) : "";
    ghost.textContent = name ? name : (snippet ? snippet : "");
  }

  function createFieldDom(field){
    const el = document.createElement('div');
    el.className = 'field';
    el.dataset.id = field.id;

    const badge = document.createElement('div');
    badge.className = 'badge';
    badge.textContent = field.tag;

    const ghost = document.createElement('div');
    ghost.className = 'ghost';

    const resizer = document.createElement('div');
    resizer.className = 'resizer';

    el.appendChild(badge);
    el.appendChild(ghost);
    el.appendChild(resizer);

    // position
    const p = normToPx(field);
    el.style.left = `${p.x}px`;
    el.style.top = `${p.y}px`;
    el.style.width = `${p.w}px`;
    el.style.height = `${p.h}px`;
    updateFieldDomGhost(el, field);

    // select on click
    el.addEventListener('mousedown', (e)=>{
      e.stopPropagation();
      setSelected(field.id);
    });

    // move if selected (drag anywhere on box)
    let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;

    el.addEventListener('pointerdown', (e)=>{
      if (e.button !== 0) return;
      if (e.target === resizer) return; // resizing handled separately
      if (state.selectedId !== field.id) return; // first click selects; second drag moves

      e.preventDefault();
      dragging = true;
      el.setPointerCapture(e.pointerId);

      startX = e.clientX;
      startY = e.clientY;
      startLeft = parseFloat(el.style.left);
      startTop  = parseFloat(el.style.top);

      const onMove = (ev)=>{
        if (!dragging) return;
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;
        const p2 = clampFieldPx({
          x: startLeft + dx,
          y: startTop + dy,
          w: parseFloat(el.style.width),
          h: parseFloat(el.style.height)
        });
        el.style.left = `${p2.x}px`;
        el.style.top  = `${p2.y}px`;
      };

      const onUp = ()=>{
        dragging = false;
        el.removeEventListener('pointermove', onMove);
        el.removeEventListener('pointerup', onUp);
        commitDomToField(el, field);
      };

      el.addEventListener('pointermove', onMove);
      el.addEventListener('pointerup', onUp, { once:true });
    });

    // resize handle (only visible when selected)
    let resizing=false, rsX=0, rsY=0, rsW=0, rsH=0;
    resizer.addEventListener('pointerdown', (e)=>{
      if (e.button !== 0) return;
      if (state.selectedId !== field.id) return;
      e.preventDefault();
      e.stopPropagation();

      resizing = true;
      resizer.setPointerCapture(e.pointerId);

      rsX = e.clientX; rsY = e.clientY;
      rsW = parseFloat(el.style.width);
      rsH = parseFloat(el.style.height);

      const onMove = (ev)=>{
        if (!resizing) return;
        const dw = ev.clientX - rsX;
        const dh = ev.clientY - rsY;
        const p2 = clampFieldPx({
          x: parseFloat(el.style.left),
          y: parseFloat(el.style.top),
          w: rsW + dw,
          h: rsH + dh
        });
        el.style.width  = `${p2.w}px`;
        el.style.height = `${p2.h}px`;
      };

      const onUp = ()=>{
        resizing = false;
        resizer.removeEventListener('pointermove', onMove);
        resizer.removeEventListener('pointerup', onUp);
        commitDomToField(el, field);
      };

      resizer.addEventListener('pointermove', onMove);
      resizer.addEventListener('pointerup', onUp, { once:true });
    });

    return el;
  }

  function commitDomToField(el, field){
    const p = clampFieldPx({
      x: parseFloat(el.style.left),
      y: parseFloat(el.style.top),
      w: parseFloat(el.style.width),
      h: parseFloat(el.style.height)
    });
    el.style.left = `${p.x}px`;
    el.style.top  = `${p.y}px`;
    el.style.width = `${p.w}px`;
    el.style.height = `${p.h}px`;
    const n = pxToNorm(p);
    field.x = n.x; field.y = n.y; field.w = n.w; field.h = n.h;
  }

  function rebuildOverlayForPage(){
    clearOverlayFields();
    const fields = getPageFields(state.page);
    for (const f of fields){
      const el = createFieldDom(f);
      overlay.appendChild(el);
    }
    refreshFieldList();
  }

  function deleteFieldById(id){
    const fields = getPageFields(state.page);
    const idx = fields.findIndex(f=>f.id===id);
    if (idx !== -1) fields.splice(idx, 1);
    const el = overlay.querySelector(`.field[data-id="${CSS.escape(id)}"]`);
    if (el) el.remove();
    setSelected(null);
    refreshFieldList();
  }

  // ---- drag-to-create a box ----
  let drawing=false, startPx=null;

  overlay.addEventListener('mousedown', (e)=>{
    if (e.target.closest('.field')) return;
    if (!state.pdfDoc) return;

    drawing = true;
    setSelected(null);

    const r = overlay.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    startPx = { x, y };

    marquee.style.display = "block";
    marquee.style.left = `${x}px`;
    marquee.style.top = `${y}px`;
    marquee.style.width = `0px`;
    marquee.style.height = `0px`;

    window.addEventListener('mousemove', onDrawMove);
    window.addEventListener('mouseup', onDrawUp, { once:true });
  });

  function onDrawMove(e){
    if (!drawing) return;
    const r = overlay.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    const left = Math.min(startPx.x, x);
    const top = Math.min(startPx.y, y);
    const w = Math.abs(x - startPx.x);
    const h = Math.abs(y - startPx.y);

    marquee.style.left = `${left}px`;
    marquee.style.top = `${top}px`;
    marquee.style.width = `${w}px`;
    marquee.style.height = `${h}px`;
  }

  function onDrawUp(){
    window.removeEventListener('mousemove', onDrawMove);
    if (!drawing) return;
    drawing = false;

    const left = parseFloat(marquee.style.left);
    const top  = parseFloat(marquee.style.top);
    const w    = parseFloat(marquee.style.width);
    const h    = parseFloat(marquee.style.height);
    marquee.style.display = "none";

    if (w < 8 || h < 8) return;

    const p = clampFieldPx({ x:left, y:top, w, h });
    const n = pxToNorm(p);

    const fields = getPageFields(state.page);
    const id = `field_${state.page}_${Date.now().toString(36)}`;
    const tag = indexToTag(state.tagCounter++);
    const field = { id, tag, label:"", value:"", x:n.x, y:n.y, w:n.w, h:n.h };

    fields.push(field);

    const el = createFieldDom(field);
    overlay.appendChild(el);
    setSelected(id);
    refreshFieldList();
    selLabelEl.focus();
  }

  // ---- Side editor wiring ----
  selLabelEl.addEventListener('input', ()=>{
    const f = state.selectedId ? getFieldById(state.selectedId) : null;
    if (!f) return;
    f.label = selLabelEl.value;
    // update overlay ghost + list
    const el = overlay.querySelector(`.field[data-id="${CSS.escape(f.id)}"]`);
    if (el) updateFieldDomGhost(el, f);
    refreshFieldList();
  });

  selValueEl.addEventListener('input', ()=>{
    const f = state.selectedId ? getFieldById(state.selectedId) : null;
    if (!f) return;
    f.value = selValueEl.value;
    const el = overlay.querySelector(`.field[data-id="${CSS.escape(f.id)}"]`);
    if (el) updateFieldDomGhost(el, f);
  });

  deleteSelBtn.addEventListener('click', ()=>{
    if (!state.selectedId) return;
    deleteFieldById(state.selectedId);
  });

  clearSelBtn.addEventListener('click', ()=>{
    const f = state.selectedId ? getFieldById(state.selectedId) : null;
    if (!f) return;
    f.value = "";
    selValueEl.value = "";
    const el = overlay.querySelector(`.field[data-id="${CSS.escape(f.id)}"]`);
    if (el) updateFieldDomGhost(el, f);
  });

  // ---- Page rendering ----
  async function renderPage(pageNo){
    const pdfjsLib = window.pdfjsLib;
    if (!state.pdfDoc) return;

    state.page = pageNo;
    pageNumEl.textContent = String(state.page);
    pageCountEl.textContent = String(state.pageCount);
    prevBtn.disabled = state.page <= 1;
    nextBtn.disabled = state.page >= state.pageCount;

    const page = await state.pdfDoc.getPage(pageNo);
    const viewport = page.getViewport({ scale: state.viewScale });

    pdfCanvas.width = Math.floor(viewport.width);
    pdfCanvas.height = Math.floor(viewport.height);

    stack.style.width = pdfCanvas.width + "px";
    stack.style.height = pdfCanvas.height + "px";
    overlay.style.width = pdfCanvas.width + "px";
    overlay.style.height = pdfCanvas.height + "px";

    await page.render({ canvasContext: pdfCtx, viewport }).promise;

    rebuildOverlayForPage();
  }

  prevBtn.addEventListener('click', async ()=>{
    if (!state.pdfDoc || state.page <= 1) return;
    setSelected(null);
    await renderPage(state.page - 1);
  });
  nextBtn.addEventListener('click', async ()=>{
    if (!state.pdfDoc || state.page >= state.pageCount) return;
    setSelected(null);
    await renderPage(state.page + 1);
  });

  // ---- Export flattened PDF ----
  function wrapText(font, text, size, maxWidth){
    const words = String(text || "").replace(/\r/g,"").split(/\s+/).filter(Boolean);
    if (!words.length) return [];

    const lines = [];
    let line = words[0];

    for (let i=1;i<words.length;i++){
      const test = line + " " + words[i];
      const w = font.widthOfTextAtSize(test, size);
      if (w <= maxWidth){
        line = test;
      } else {
        if (font.widthOfTextAtSize(words[i], size) > maxWidth){
          const chunked = breakWord(font, words[i], size, maxWidth);
          lines.push(line);
          lines.push(...chunked.slice(0, chunked.length-1));
          line = chunked[chunked.length-1];
        } else {
          lines.push(line);
          line = words[i];
        }
      }
    }
    lines.push(line);
    return lines;
  }

  function breakWord(font, word, size, maxWidth){
    const out=[];
    let cur="";
    for (const ch of word){
      const test = cur + ch;
      if (font.widthOfTextAtSize(test, size) <= maxWidth){
        cur = test;
      } else {
        if (cur) out.push(cur);
        cur = ch;
      }
    }
    if (cur) out.push(cur);
    return out.length ? out : [word];
  }

  async function exportPdf(){
    if (!state.pdfBytes || !state.pdfDoc) return;

    const { PDFDocument, StandardFonts, rgb } = window.PDFLib;
    const pdf = await PDFDocument.load(state.pdfBytes);
    const font = await pdf.embedFont(StandardFonts.Helvetica);
    const pages = pdf.getPages();

    for (let p=1; p<=state.pageCount; p++){
      const fields = state.pages[p] || [];
      if (!fields.length) continue;

      const page = pages[p-1];
      const { width, height } = page.getSize();

      for (const f of fields){
        const value = (f.value || "").trim();
        if (!value) continue;

        const margin = 2;
        const boxX = f.x * width;
        const boxYTopFromTop = f.y * height;
        const boxW = f.w * width;
        const boxH = f.h * height;

        const fontSize = 11;
        const lineGap = 2;
        const maxW = Math.max(10, boxW - margin*2);

        const paragraphs = String(f.value || "").replace(/\r/g,"").split("\n");
        let lines = [];
        for (const para of paragraphs){
          if (!para.trim()){ lines.push(""); continue; }
          lines.push(...wrapText(font, para, fontSize, maxW));
        }

        // PDF coords: origin bottom-left; start near top inside box
        const topY = height - boxYTopFromTop - margin;
        let y = topY - fontSize;
        const minY = height - (boxYTopFromTop + boxH) + margin;

        for (const line of lines){
          if (y < minY) break;
          page.drawText(line, {
            x: boxX + margin,
            y,
            size: fontSize,
            font,
            color: rgb(0,0,0),
            maxWidth: maxW
          });
          y -= (fontSize + lineGap);
        }
      }
    }

    const outBytes = await pdf.save();
    const blob = new Blob([outBytes], { type:"application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = state.baseName + "_updated.pdf";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  exportBtn.addEventListener('click', async ()=>{
    exportBtn.disabled = true;
    exportBtn.textContent = "Building PDF...";
    try{
      await exportPdf();
      showBanner("");
    }catch(err){
      console.error(err);
      showBanner(`<b>Export failed.</b><br/><code>${escapeHtml(String(err?.message || err))}</code>`);
    }finally{
      exportBtn.textContent = "Download Updated PDF";
      exportBtn.disabled = false;
    }
  });

  // ---- Load PDF ----
  async function loadPdfFromFile(file){
    state.baseName = safeBaseName(file.name);
    state.pdfBytes = await file.arrayBuffer();

    const typed = new Uint8Array(state.pdfBytes);
    const loadingTask = window.pdfjsLib.getDocument({ data: typed });
    state.pdfDoc = await loadingTask.promise;

    state.pageCount = state.pdfDoc.numPages;
    state.page = 1;

    pageCountEl.textContent = String(state.pageCount);
    pageNumEl.textContent = "1";
    prevBtn.disabled = true;
    nextBtn.disabled = state.pageCount <= 1;

    exportBtn.disabled = false;

    // reset annotations for simplicity
    state.pages = {};
    state.selectedId = null;
    state.tagCounter = 0;

    setSelected(null);
    await renderPage(1);
  }

  fileEl.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    try{
      await loadPdfFromFile(f);
      showBanner("");
    }catch(err){
      console.error(err);
      showBanner(`<b>PDF load failed.</b><br/><code>${escapeHtml(String(err?.message || err))}</code>`);
    }
  });

  // ---- Boot: load libs ----
  (async ()=>{
    try{
      await loadPdfJs();
      await loadPdfLib();
    }catch(err){
      console.error(err);
      showBanner(`
        <b>Couldn’t load required libraries.</b><br/>
        Your network may block CDNs or you may be offline.<br/>
        Error: <code>${escapeHtml(String(err?.message || err))}</code>
      `);
    }
  })();

})();
</script>
</body>
</html>
