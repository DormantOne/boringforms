<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Write-On (Drag box → see text live → drag to move)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Same versions you said worked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <style>
    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#f5f5f7;
      color:#111827;
    }
    header{
      background:#111827;
      color:#fff;
      padding:10px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      position:sticky;
      top:0;
      z-index:20;
    }
    header .pill{
      display:inline-flex;
      align-items:center;
      gap:.4rem;
      padding:.25rem .6rem;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-size:.82rem;
      opacity:0.95;
      white-space:nowrap;
    }
    header input[type="file"]{ color:#e5e7eb; }
    header button{
      border:none;
      border-radius:8px;
      padding:8px 10px;
      font-size:.85rem;
      font-weight:700;
      cursor:pointer;
      background:#2563eb;
      color:#fff;
    }
    header button.secondary{ background:#374151; }
    header button.danger{ background:#dc2626; }
    header button:disabled{ opacity:.55; cursor:default; }

    .wrap{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:flex-start;
    }
    @media (max-width: 980px){
      .wrap{ flex-direction:column; }
    }

    .panel{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:12px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
      padding:12px;
    }

    #pdfPanel{ flex:2; min-width:320px; }
    #pdfStage{
      position:relative;
      display:inline-block;
      max-width:100%;
      border-radius:10px;
      overflow:hidden;
      border:1px solid #e5e7eb;
      background:#111827;
      touch-action:none;
    }
    #pdfCanvas{
      display:block;
      max-width:100%;
      height:auto;
      background:#111827;
    }
    #overlay{
      position:absolute;
      inset:0;
      pointer-events:auto;
    }

    /* Field box: color only (no labels) */
    .field-box{
      position:absolute;
      box-sizing:border-box;
      border:2px solid rgba(56,189,248,0.95);
      background: rgba(56,189,248,0.14);
      border-radius:8px;
      cursor:move; /* because you can drag it */
      user-select:none;
    }
    .field-box.selected{
      border-color: rgba(34,197,94,0.95) !important;
      background: rgba(34,197,94,0.14) !important;
    }

    /* ONE text layer only: light gray */
    .field-text{
      position:absolute;
      inset:2px;                 /* keep it tight = correct placement */
      font-size:14px;
      line-height:1.12;
      color: rgba(235,235,235,0.92); /* light gray */
      white-space: pre-wrap;
      overflow:hidden;
      pointer-events:none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.65); /* readable on busy forms */
    }

    /* While drawing new box: show it immediately */
    .temp-box{
      position:absolute;
      box-sizing:border-box;
      border:2px dashed rgba(56,189,248,0.95);
      background: rgba(56,189,248,0.10);
      border-radius:8px;
      pointer-events:none;
    }

    .page-controls{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:10px;
      font-size:.88rem;
      color:#111827;
    }
    .hint{
      font-size:.85rem;
      color:#6b7280;
      line-height:1.35;
    }

    #sidePanel{ flex:1; min-width:280px; max-width:420px; position:sticky; top:64px; }
    @media (max-width: 980px){ #sidePanel{ position:static; max-width:none; } }

    label{
      display:block;
      font-size:.82rem;
      color:#374151;
      margin:10px 0 6px;
    }
    input[type="text"], textarea{
      width:100%;
      box-sizing:border-box;
      border:1px solid #d1d5db;
      border-radius:8px;
      padding:8px 10px;
      font-size:.9rem;
      background:#fff;
    }
    textarea{ min-height:130px; resize:vertical; }

    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .field-list{
      margin-top:12px;
      border-top:1px solid #e5e7eb;
      padding-top:10px;
      max-height:260px;
      overflow:auto;
    }
    .field-item{
      border:1px solid #e5e7eb;
      border-radius:10px;
      padding:8px;
      margin-bottom:8px;
      background:#fff;
      cursor:pointer;
    }
    .field-item.selected{
      border-color:#2563eb;
      background:#eff6ff;
    }
    .field-item .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .swatch{
      width:10px; height:10px; border-radius:999px;
      border:1px solid rgba(0,0,0,0.15);
      display:inline-block;
      margin-right:6px;
      vertical-align:middle;
    }
    .field-item b{ font-size:.9rem; }
    .field-item small{
      color:#6b7280;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
  </style>
</head>

<body>
  <header>
    <input id="pdfFile" type="file" accept="application/pdf" />
    <button id="downloadPdf" class="secondary" disabled>Download filled PDF</button>

    <span class="pill">Drag to draw box • Click box • Type (shows live)</span>
    <span class="pill" id="pdfNamePill">PDF: (none)</span>
    <span class="pill">Page <span id="pageNum">–</span> / <span id="pageCount">–</span></span>

    <button id="prevBtn" class="secondary" disabled>Prev</button>
    <button id="nextBtn" class="secondary" disabled>Next</button>
  </header>

  <div class="wrap">
    <div id="pdfPanel" class="panel">
      <div class="hint" style="margin-bottom:10px;">
        Draw a field by dragging on empty space. Drag an existing box to move it. Press <b>Delete</b> to remove selected box.
      </div>

      <div id="pdfStage">
        <canvas id="pdfCanvas"></canvas>
        <div id="overlay"></div>
      </div>

      <div class="page-controls">
        <div class="hint">No labels on boxes (clean). Hover shows label.</div>
        <div class="hint">Download flattens your typed text into the PDF.</div>
      </div>
    </div>

    <div id="sidePanel" class="panel">
      <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
        <h3 style="margin:0; font-size:1rem;">Selected Field</h3>
        <small id="selId" style="color:#6b7280;">(none)</small>
      </div>

      <div id="noSel" class="hint" style="margin-top:8px;">
        Nothing selected. Draw a box or click a box.
      </div>

      <div id="selUI" style="display:none;">
        <label>Label (only shown here; boxes stay clean)</label>
        <input id="labelInput" type="text" placeholder="e.g., Patient name" />

        <label>Value (shows live ON the PDF)</label>
        <textarea id="valueInput" placeholder="Type here…"></textarea>

        <div class="row">
          <button id="deleteBtn" class="danger">Delete field</button>
          <button id="clearBtn" class="secondary">Clear text</button>
        </div>
      </div>

      <div class="field-list">
        <div style="display:flex; justify-content:space-between; align-items:baseline;">
          <h3 style="margin:0; font-size:.95rem;">Fields on this page</h3>
          <small class="hint" id="fieldCountText">0</small>
        </div>
        <div id="fieldList" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";

  const COLOR_PALETTE = [
    "#dc2626","#eab308","#f97316","#2563eb","#16a34a","#9333ea","#06b6d4","#f43f5e"
  ];

  const elPdfFile = document.getElementById("pdfFile");
  const elDownloadPdf = document.getElementById("downloadPdf");
  const elPrev = document.getElementById("prevBtn");
  const elNext = document.getElementById("nextBtn");
  const elPageNum = document.getElementById("pageNum");
  const elPageCount = document.getElementById("pageCount");
  const elPdfNamePill = document.getElementById("pdfNamePill");

  const pdfCanvas = document.getElementById("pdfCanvas");
  const ctx = pdfCanvas.getContext("2d");
  const overlay = document.getElementById("overlay");

  const selIdEl = document.getElementById("selId");
  const noSelEl = document.getElementById("noSel");
  const selUIEl = document.getElementById("selUI");
  const labelInput = document.getElementById("labelInput");
  const valueInput = document.getElementById("valueInput");
  const deleteBtn = document.getElementById("deleteBtn");
  const clearBtn = document.getElementById("clearBtn");

  const fieldListEl = document.getElementById("fieldList");
  const fieldCountText = document.getElementById("fieldCountText");

  let pdfDoc = null;
  let originalPdfBytes = null;
  let loadedPdfName = "";
  let currentPageNumber = 1;
  let scale = 1.25;

  const mapping = { pages: [] };
  const fieldValues = {};
  let selectedFieldId = null;
  let colorById = Object.create(null);

  function clamp01(n){ return Math.max(0, Math.min(1, n)); }
  function hexToRgba(hex, a){
    const h = String(hex||"").replace("#","");
    if (h.length !== 6) return `rgba(255,255,255,${a})`;
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }
  function escapeHtml(s){
    return String(s||"")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }

  function getOrCreatePage(pageNumber){
    let p = mapping.pages.find(x => x.pageNumber === pageNumber);
    if (!p){
      p = { pageNumber, fields: [] };
      mapping.pages.push(p);
      mapping.pages.sort((a,b)=>a.pageNumber-b.pageNumber);
    }
    return p;
  }
  function getCurrentPageObj(){ return getOrCreatePage(currentPageNumber); }

  function getFieldById(fieldId){
    for (const p of mapping.pages){
      const f = (p.fields||[]).find(x => x.id === fieldId);
      if (f) return { page: p, field: f };
    }
    return null;
  }

  function rebuildColorMap(){
    colorById = Object.create(null);
    const pages = mapping.pages.slice().sort((a,b)=>a.pageNumber-b.pageNumber);
    let i = 0;
    for (const p of pages){
      for (const f of (p.fields||[])){
        colorById[f.id] = COLOR_PALETTE[i % COLOR_PALETTE.length];
        i++;
      }
    }
  }
  function colorForId(id){ return colorById[id] || COLOR_PALETTE[0]; }

  function setSelected(fieldId){
    selectedFieldId = fieldId || null;

    if (!selectedFieldId){
      selIdEl.textContent = "(none)";
      noSelEl.style.display = "block";
      selUIEl.style.display = "none";
    } else {
      const res = getFieldById(selectedFieldId);
      selIdEl.textContent = selectedFieldId;
      noSelEl.style.display = "none";
      selUIEl.style.display = "block";
      labelInput.value = res?.field?.label || "";
      valueInput.value = fieldValues[selectedFieldId] || "";
    }

    overlay.querySelectorAll(".field-box").forEach(box=>{
      box.classList.toggle("selected", box.dataset.id === selectedFieldId);
    });
    fieldListEl.querySelectorAll(".field-item").forEach(item=>{
      item.classList.toggle("selected", item.dataset.id === selectedFieldId);
    });
  }

  function removeField(fieldId){
    for (const p of mapping.pages){
      const idx = (p.fields||[]).findIndex(x => x.id === fieldId);
      if (idx !== -1){
        p.fields.splice(idx,1);
        delete fieldValues[fieldId];
        break;
      }
    }
    if (selectedFieldId === fieldId) setSelected(null);
    rebuildColorMap();
    renderFieldBoxes();
    renderFieldList();
  }

  async function renderPage(num){
    if (!pdfDoc) return;
    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({ scale });

    pdfCanvas.width = viewport.width;
    pdfCanvas.height = viewport.height;

    await page.render({ canvasContext: ctx, viewport }).promise;

    elPageNum.textContent = String(num);
    elPageCount.textContent = String(pdfDoc.numPages);
    elPrev.disabled = num <= 1;
    elNext.disabled = num >= pdfDoc.numPages;

    renderFieldBoxes();
    renderFieldList();
  }

  // ====== Draw boxes + text ======
  function renderFieldBoxes(){
    overlay.innerHTML = "";

    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];

    for (const f of fields){
      const box = document.createElement("div");
      box.className = "field-box";
      box.dataset.id = f.id;

      const col = colorForId(f.id);
      box.style.borderColor = col;
      box.style.background = hexToRgba(col, 0.14);

      box.style.left   = (f.x * 100) + "%";
      box.style.top    = (f.y * 100) + "%";
      box.style.width  = (f.width * 100) + "%";
      box.style.height = (f.height * 100) + "%";

      box.title = (f.label || f.id);

      const text = document.createElement("div");
      text.className = "field-text";
      text.textContent = (fieldValues[f.id] || "");
      box.appendChild(text);

      // Click selects; drag moves (pointer events)
      box.addEventListener("pointerdown", startDragMoveBox);

      overlay.appendChild(box);
    }

    setSelected(selectedFieldId);
  }

  function renderFieldList(){
    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];
    fieldCountText.textContent = String(fields.length);

    fieldListEl.innerHTML = "";
    if (!fields.length){
      fieldListEl.innerHTML = `<div class="hint">No fields on this page. Drag on empty space to create one.</div>`;
      return;
    }

    for (const f of fields){
      const item = document.createElement("div");
      item.className = "field-item";
      item.dataset.id = f.id;
      if (f.id === selectedFieldId) item.classList.add("selected");

      const col = colorForId(f.id);
      const label = f.label || "(no label)";
      item.innerHTML = `
        <div class="top">
          <div>
            <span class="swatch" style="background:${col}"></span>
            <b>${escapeHtml(label)}</b>
          </div>
          <small>${escapeHtml(f.id)}</small>
        </div>
      `;
      item.addEventListener("click", ()=>{
        setSelected(f.id);
        const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(f.id)}"]`);
        if (box) box.scrollIntoView({ block:"nearest", inline:"nearest" });
      });
      fieldListEl.appendChild(item);
    }
  }

  // ====== Create new box by dragging on EMPTY space ======
  let drawing = false;
  let startPt = null;
  let tempBox = null;

  function overlayRect(){ return overlay.getBoundingClientRect(); }

  overlay.addEventListener("pointerdown", (e)=>{
    if (!pdfDoc) return;

    // If the user clicked a box, the box handler stops propagation.
    setSelected(null);

    const r = overlayRect();
    const x = clamp01((e.clientX - r.left) / r.width);
    const y = clamp01((e.clientY - r.top) / r.height);

    drawing = true;
    startPt = { x, y };

    tempBox = document.createElement("div");
    tempBox.className = "temp-box";
    tempBox.style.left = (x * 100) + "%";
    tempBox.style.top = (y * 100) + "%";
    tempBox.style.width = "0%";
    tempBox.style.height = "0%";
    overlay.appendChild(tempBox);

    overlay.setPointerCapture(e.pointerId);
  });

  overlay.addEventListener("pointermove", (e)=>{
    if (!drawing || !startPt || !tempBox) return;
    const r = overlayRect();
    const x = clamp01((e.clientX - r.left) / r.width);
    const y = clamp01((e.clientY - r.top) / r.height);

    const left = Math.min(startPt.x, x);
    const top  = Math.min(startPt.y, y);
    const w = Math.abs(x - startPt.x);
    const h = Math.abs(y - startPt.y);

    tempBox.style.left = (left * 100) + "%";
    tempBox.style.top  = (top * 100) + "%";
    tempBox.style.width  = (w * 100) + "%";
    tempBox.style.height = (h * 100) + "%";
  });

  overlay.addEventListener("pointerup", (e)=>{
    if (!drawing) return;
    drawing = false;

    if (!tempBox || !startPt) return;

    const left = parseFloat(tempBox.style.left) / 100;
    const top = parseFloat(tempBox.style.top) / 100;
    const width = parseFloat(tempBox.style.width) / 100;
    const height = parseFloat(tempBox.style.height) / 100;

    tempBox.remove();
    tempBox = null;

    if (width < 0.01 || height < 0.01) return;

    const pageObj = getCurrentPageObj();
    const newId = `field_${currentPageNumber}_${pageObj.fields.length + 1}`;

    pageObj.fields.push({ id:newId, label:"", x:left, y:top, width, height });
    fieldValues[newId] = "";

    rebuildColorMap();
    setSelected(newId);
    renderFieldBoxes();
    renderFieldList();
  });

  // ====== Drag existing box to MOVE it ======
  let dragMove = null; // { id, startClientX, startClientY, startX, startY, width, height, rect }

  function startDragMoveBox(ev){
    ev.stopPropagation(); // do not start drawing a new box
    const id = ev.currentTarget.dataset.id;
    if (!id) return;

    setSelected(id);

    const res = getFieldById(id);
    if (!res) return;

    const r = overlayRect();
    dragMove = {
      id,
      startClientX: ev.clientX,
      startClientY: ev.clientY,
      startX: res.field.x,
      startY: res.field.y,
      w: res.field.width,
      h: res.field.height,
      rect: r
    };

    ev.currentTarget.setPointerCapture(ev.pointerId);
    ev.currentTarget.addEventListener("pointermove", onDragMoveBox);
    ev.currentTarget.addEventListener("pointerup", endDragMoveBox, { once:true });
    ev.currentTarget.addEventListener("pointercancel", endDragMoveBox, { once:true });
  }

  function onDragMoveBox(ev){
    if (!dragMove) return;
    const res = getFieldById(dragMove.id);
    if (!res) return;

    const dx = (ev.clientX - dragMove.startClientX) / dragMove.rect.width;
    const dy = (ev.clientY - dragMove.startClientY) / dragMove.rect.height;

    // clamp so box stays on page
    const newX = clamp01(dragMove.startX + dx);
    const newY = clamp01(dragMove.startY + dy);
    res.field.x = Math.max(0, Math.min(1 - dragMove.w, newX));
    res.field.y = Math.max(0, Math.min(1 - dragMove.h, newY));

    // update element directly (smooth)
    const boxEl = overlay.querySelector(`.field-box[data-id="${CSS.escape(dragMove.id)}"]`);
    if (boxEl){
      boxEl.style.left = (res.field.x * 100) + "%";
      boxEl.style.top  = (res.field.y * 100) + "%";
    }
  }

  function endDragMoveBox(ev){
    const boxEl = ev.currentTarget;
    boxEl.removeEventListener("pointermove", onDragMoveBox);
    dragMove = null;
    renderFieldList(); // update selection UI list (optional)
  }

  // ====== Side panel: live updates ON the PDF ======
  labelInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    const res = getFieldById(selectedFieldId);
    if (!res) return;
    res.field.label = labelInput.value;

    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    if (box) box.title = res.field.label || res.field.id;

    renderFieldList();
  });

  valueInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = valueInput.value;

    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    const text = box?.querySelector(".field-text");
    if (text) text.textContent = valueInput.value; // live on PDF
  });

  deleteBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    removeField(selectedFieldId);
  });

  clearBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = "";
    valueInput.value = "";
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    const text = box?.querySelector(".field-text");
    if (text) text.textContent = "";
  });

  // Keyboard delete (when not typing)
  document.addEventListener("keydown", (e)=>{
    const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
    const typing = (tag === "input" || tag === "textarea");
    if (typing) return;
    if ((e.key === "Delete" || e.key === "Backspace") && selectedFieldId){
      e.preventDefault();
      removeField(selectedFieldId);
    }
  });

  // Page nav
  elPrev.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber <= 1) return;
    currentPageNumber--;
    setSelected(null);
    await renderPage(currentPageNumber);
  });

  elNext.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber >= pdfDoc.numPages) return;
    currentPageNumber++;
    setSelected(null);
    await renderPage(currentPageNumber);
  });

  // Load PDF
  elPdfFile.addEventListener("change", (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    loadedPdfName = file.name;
    elPdfNamePill.textContent = "PDF: " + loadedPdfName;

    const reader = new FileReader();
    reader.onload = async (ev)=>{
      originalPdfBytes = ev.target.result;

      const typedarray = new Uint8Array(originalPdfBytes);
      pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
      currentPageNumber = 1;

      // reset (keep simple)
      mapping.pages = [];
      for (const k of Object.keys(fieldValues)) delete fieldValues[k];
      selectedFieldId = null;

      rebuildColorMap();
      elDownloadPdf.disabled = false;
      elPageCount.textContent = String(pdfDoc.numPages);

      await renderPage(currentPageNumber);
    };
    reader.readAsArrayBuffer(file);
  });

  // ====== Export: flatten into PDF ======
  function safeBaseName(s){
    return (s || "filled_form").replace(/\.pdf$/i,"").replace(/[^\w\-]+/g,"_").slice(0,80) || "filled_form";
  }

  function wrapText(font, text, size, maxWidth){
    const words = String(text||"").replace(/\r/g,"").split(/\s+/).filter(Boolean);
    if (!words.length) return [];
    const lines = [];
    let line = words[0];

    for (let i=1;i<words.length;i++){
      const test = line + " " + words[i];
      const w = font.widthOfTextAtSize(test, size);
      if (w <= maxWidth) line = test;
      else { lines.push(line); line = words[i]; }
    }
    lines.push(line);
    return lines;
  }

  async function downloadFilledPdf(){
    if (!originalPdfBytes || !pdfDoc) { alert("Load a PDF first."); return; }

    const { PDFDocument, StandardFonts, rgb } = PDFLib;
    const pdf = await PDFDocument.load(originalPdfBytes);
    const pages = pdf.getPages();
    const font = await pdf.embedFont(StandardFonts.Helvetica);

    for (const pageMapping of mapping.pages){
      const pageIndex = pageMapping.pageNumber - 1;
      if (pageIndex < 0 || pageIndex >= pages.length) continue;

      const page = pages[pageIndex];
      const { width, height } = page.getSize();

      for (const f of (pageMapping.fields||[])){
        const val = (fieldValues[f.id] || "").trim();
        if (!val) continue;

        const boxX = f.x * width;
        const boxYFromTop = f.y * height;
        const boxW = f.width * width;
        const boxH = f.height * height;

        const margin = 2;
        const fontSize = 11;
        const lineGap = 2;

        const maxW = Math.max(10, boxW - margin*2);
        const paragraphs = String(fieldValues[f.id] || "").replace(/\r/g,"").split("\n");

        let lines = [];
        for (const para of paragraphs){
          if (!para.trim()){ lines.push(""); continue; }
          lines.push(...wrapText(font, para, fontSize, maxW));
        }

        const topY = height - boxYFromTop - margin;
        let y = topY - fontSize;
        const minY = height - (boxYFromTop + boxH) + margin;

        for (const line of lines){
          if (y < minY) break;
          page.drawText(line, {
            x: boxX + margin,
            y,
            size: fontSize,
            font,
            color: rgb(0,0,0),
            maxWidth: maxW
          });
          y -= (fontSize + lineGap);
        }
      }
    }

    const outBytes = await pdf.save();
    const blob = new Blob([outBytes], { type:"application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = safeBaseName(loadedPdfName) + "_filled.pdf";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  elDownloadPdf.addEventListener("click", ()=>{
    downloadFilledPdf().catch(err=>{
      console.error(err);
      alert("Failed to generate PDF. See console.");
    });
  });
</script>
</body>
</html>
