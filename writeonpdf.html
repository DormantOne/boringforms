<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Write-On (Draw Box → Type On PDF)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Use the SAME versions that worked for you -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <style>
    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#f5f5f7;
      color:#111827;
    }

    header{
      background:#111827;
      color:#fff;
      padding:10px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      position:sticky;
      top:0;
      z-index:20;
    }
    header .pill{
      display:inline-flex;
      align-items:center;
      gap:.4rem;
      padding:.25rem .6rem;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-size:.82rem;
      opacity:0.95;
      white-space:nowrap;
    }
    header input[type="file"]{ color:#e5e7eb; }
    header button{
      border:none;
      border-radius:8px;
      padding:8px 10px;
      font-size:.85rem;
      font-weight:700;
      cursor:pointer;
      background:#2563eb;
      color:#fff;
    }
    header button.secondary{ background:#374151; }
    header button.danger{ background:#dc2626; }
    header button:disabled{ opacity:.55; cursor:default; }

    .wrap{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:flex-start;
    }
    @media (max-width: 980px){
      .wrap{ flex-direction:column; }
    }

    .panel{
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:12px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
      padding:12px;
    }

    /* LEFT: PDF */
    #pdfPanel{ flex:2; min-width:320px; }
    #pdfStage{
      position:relative;
      display:inline-block;
      max-width:100%;
      border-radius:10px;
      overflow:hidden;
      border:1px solid #e5e7eb;
      background:#111827;
      touch-action:none; /* allows pointer drawing on touch */
    }
    #pdfCanvas{
      display:block;
      max-width:100%;
      height:auto;
      background:#111827;
    }
    #overlay{
      position:absolute;
      inset:0;
      pointer-events:auto;
    }

    /* Field box: NO LABELS. Color only. */
    .field-box{
      position:absolute;
      box-sizing:border-box;
      border:2px solid rgba(56,189,248,0.95);
      background: rgba(56,189,248,0.16);
      border-radius:8px;
      cursor:pointer;
      user-select:none;
    }
    .field-box.selected{
      border-color: rgba(34,197,94,0.95) !important;
      background: rgba(34,197,94,0.16) !important;
    }

    /* MUST SEE TEXT on the PDF: black text with strong white outline */
    .field-text{
      position:absolute;
      inset:4px;
      font-size:14px;
      line-height:1.12;
      color: rgba(0,0,0,0.88);
      white-space: pre-wrap;
      overflow:hidden;
      pointer-events:none;
      text-shadow:
        -1px -1px 0 rgba(255,255,255,0.96),
         1px -1px 0 rgba(255,255,255,0.96),
        -1px  1px 0 rgba(255,255,255,0.96),
         1px  1px 0 rgba(255,255,255,0.96),
         0px  0px 4px rgba(255,255,255,0.95);
    }

    /* Inline editor shown only when selected */
    .field-editor{
      position:absolute;
      inset:2px;
      width:calc(100% - 4px);
      height:calc(100% - 4px);
      box-sizing:border-box;
      border:none;
      outline:none;
      resize:none;
      background: rgba(255,255,255,0.35);
      color:#0b1120;
      font-size:14px;
      line-height:1.12;
      padding:6px;
      border-radius:6px;
      display:none;
    }
    .field-box.selected .field-editor{ display:block; }

    /* Drawing marquee */
    .temp-box{
      position:absolute;
      border:2px dashed rgba(255,255,255,0.85);
      background: rgba(255,255,255,0.08);
      border-radius:8px;
      pointer-events:none;
    }

    /* Page controls */
    .page-controls{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:10px;
      font-size:.88rem;
      color:#111827;
    }
    .page-controls .left{
      display:flex; gap:8px; align-items:center;
    }

    /* RIGHT: Selected field */
    #sidePanel{ flex:1; min-width:280px; max-width:420px; position:sticky; top:64px; }
    @media (max-width: 980px){ #sidePanel{ position:static; max-width:none; } }

    label{
      display:block;
      font-size:.82rem;
      color:#374151;
      margin:10px 0 6px;
    }
    input[type="text"], textarea{
      width:100%;
      box-sizing:border-box;
      border:1px solid #d1d5db;
      border-radius:8px;
      padding:8px 10px;
      font-size:.9rem;
      background:#fff;
    }
    textarea{ min-height:130px; resize:vertical; }

    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .hint{
      font-size:.85rem;
      color:#6b7280;
      line-height:1.35;
    }

    /* Field list */
    .field-list{
      margin-top:12px;
      border-top:1px solid #e5e7eb;
      padding-top:10px;
      max-height:260px;
      overflow:auto;
    }
    .field-item{
      border:1px solid #e5e7eb;
      border-radius:10px;
      padding:8px;
      margin-bottom:8px;
      background:#fff;
      cursor:pointer;
    }
    .field-item.selected{
      border-color:#2563eb;
      background:#eff6ff;
    }
    .field-item .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .swatch{
      width:10px; height:10px; border-radius:999px;
      border:1px solid rgba(0,0,0,0.15);
      display:inline-block;
      margin-right:6px;
      vertical-align:middle;
    }
    .field-item b{ font-size:.9rem; }
    .field-item small{ color:#6b7280; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>
</head>

<body>
  <header>
    <input id="pdfFile" type="file" accept="application/pdf" />
    <button id="downloadPdf" class="secondary" disabled>Download filled PDF</button>

    <span class="pill">Draw a box → click it → type (text shows on PDF)</span>

    <span class="pill" id="pdfNamePill">PDF: (none)</span>

    <span class="pill">
      Page <span id="pageNum">–</span> / <span id="pageCount">–</span>
    </span>

    <button id="prevBtn" class="secondary" disabled>Prev</button>
    <button id="nextBtn" class="secondary" disabled>Next</button>
  </header>

  <div class="wrap">
    <div id="pdfPanel" class="panel">
      <div class="hint" style="margin-bottom:10px;">
        Drag on the PDF to create a field. <b>No labels</b> on boxes—only color. Click a box to see/edit its label in the right panel.
      </div>

      <div id="pdfStage">
        <canvas id="pdfCanvas"></canvas>
        <div id="overlay"></div>
      </div>

      <div class="page-controls">
        <div class="left hint">
          Tip: press <b>Delete</b> to remove selected box.
        </div>
        <div class="hint">
          Boxes are just UI. Download flattens the text into the PDF.
        </div>
      </div>
    </div>

    <div id="sidePanel" class="panel">
      <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
        <h3 style="margin:0; font-size:1rem;">Selected Field</h3>
        <small id="selId" style="color:#6b7280;">(none)</small>
      </div>

      <div id="noSel" class="hint" style="margin-top:8px;">
        Nothing selected. Draw a box or click a box.
      </div>

      <div id="selUI" style="display:none;">
        <label>Label (only shown here; boxes stay clean)</label>
        <input id="labelInput" type="text" placeholder="e.g., Patient name" />

        <label>Value (this shows live ON the PDF)</label>
        <textarea id="valueInput" placeholder="Type here…"></textarea>

        <div class="row">
          <button id="deleteBtn" class="danger">Delete field</button>
          <button id="clearBtn" class="secondary">Clear text</button>
        </div>

        <div class="hint" style="margin-top:10px;">
          You can also type directly inside the selected box on the PDF (it opens an inline editor).
        </div>
      </div>

      <div class="field-list">
        <div style="display:flex; justify-content:space-between; align-items:baseline;">
          <h3 style="margin:0; font-size:.95rem;">Fields on this page</h3>
          <small class="hint" id="fieldCountText">0</small>
        </div>
        <div id="fieldList" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

<script>
  // pdf.js worker (same version)
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";

  // Color cycle (same vibe as your working code)
  const COLOR_PALETTE = [
    "#dc2626", // red
    "#eab308", // yellow
    "#f97316", // orange
    "#2563eb", // blue
    "#16a34a", // green
    "#9333ea", // purple
    "#06b6d4", // cyan
    "#f43f5e"  // pink
  ];

  const elPdfFile = document.getElementById("pdfFile");
  const elDownloadPdf = document.getElementById("downloadPdf");
  const elPrev = document.getElementById("prevBtn");
  const elNext = document.getElementById("nextBtn");
  const elPageNum = document.getElementById("pageNum");
  const elPageCount = document.getElementById("pageCount");
  const elPdfNamePill = document.getElementById("pdfNamePill");

  const pdfCanvas = document.getElementById("pdfCanvas");
  const ctx = pdfCanvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const pdfStage = document.getElementById("pdfStage");

  const selIdEl = document.getElementById("selId");
  const noSelEl = document.getElementById("noSel");
  const selUIEl = document.getElementById("selUI");
  const labelInput = document.getElementById("labelInput");
  const valueInput = document.getElementById("valueInput");
  const deleteBtn = document.getElementById("deleteBtn");
  const clearBtn = document.getElementById("clearBtn");

  const fieldListEl = document.getElementById("fieldList");
  const fieldCountText = document.getElementById("fieldCountText");

  // State
  let pdfDoc = null;
  let originalPdfBytes = null;
  let loadedPdfName = "";
  let currentPageNumber = 1;
  let scale = 1.25;

  // mapping: pages -> fields with normalized coords (0..1) relative to overlay DOM size
  const mapping = { pages: [] };
  const fieldValues = {}; // id -> string
  let selectedFieldId = null;
  let colorById = Object.create(null);

  function escapeHtml(s){
    return String(s||"")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }

  function getOrCreatePage(pageNumber){
    let p = mapping.pages.find(x => x.pageNumber === pageNumber);
    if (!p){
      p = { pageNumber, fields: [] };
      mapping.pages.push(p);
      mapping.pages.sort((a,b)=>a.pageNumber-b.pageNumber);
    }
    return p;
  }
  function getCurrentPageObj(){ return getOrCreatePage(currentPageNumber); }

  function rebuildColorMap(){
    colorById = Object.create(null);
    const pages = mapping.pages.slice().sort((a,b)=>a.pageNumber-b.pageNumber);
    let i = 0;
    for (const p of pages){
      for (const f of (p.fields||[])){
        colorById[f.id] = COLOR_PALETTE[i % COLOR_PALETTE.length];
        i++;
      }
    }
  }
  function colorForId(id){ return colorById[id] || COLOR_PALETTE[0]; }

  function setSelected(fieldId){
    selectedFieldId = fieldId || null;

    // update UI
    if (!selectedFieldId){
      selIdEl.textContent = "(none)";
      noSelEl.style.display = "block";
      selUIEl.style.display = "none";
    } else {
      const res = getFieldById(selectedFieldId);
      selIdEl.textContent = selectedFieldId;
      noSelEl.style.display = "none";
      selUIEl.style.display = "block";
      labelInput.value = res?.field?.label || "";
      valueInput.value = fieldValues[selectedFieldId] || "";
    }

    // update box selection styling + inline editor visibility
    overlay.querySelectorAll(".field-box").forEach(box=>{
      const id = box.dataset.id;
      box.classList.toggle("selected", id === selectedFieldId);
      const editor = box.querySelector(".field-editor");
      if (editor){
        if (id === selectedFieldId){
          editor.value = fieldValues[id] || "";
        } else {
          editor.blur();
        }
      }
    });

    // update list selection
    overlay.querySelectorAll(".field-item").forEach(item=>{
      item.classList.toggle("selected", item.dataset.id === selectedFieldId);
    });
  }

  function getFieldById(fieldId){
    for (const p of mapping.pages){
      const f = (p.fields||[]).find(x => x.id === fieldId);
      if (f) return { page: p, field: f };
    }
    return null;
  }

  function removeField(fieldId){
    for (const p of mapping.pages){
      const idx = (p.fields||[]).findIndex(x => x.id === fieldId);
      if (idx !== -1){
        p.fields.splice(idx,1);
        delete fieldValues[fieldId];
        break;
      }
    }
    if (selectedFieldId === fieldId) setSelected(null);
    rebuildColorMap();
    renderFieldBoxes();
    renderFieldList();
  }

  function clamp01(n){ return Math.max(0, Math.min(1, n)); }

  // Render PDF page
  async function renderPage(num){
    if (!pdfDoc) return;

    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({ scale });

    pdfCanvas.width = viewport.width;
    pdfCanvas.height = viewport.height;

    // Let CSS scale if needed; overlay uses % so it stays aligned.
    await page.render({ canvasContext: ctx, viewport }).promise;

    elPageNum.textContent = String(num);
    elPageCount.textContent = String(pdfDoc.numPages);
    elPrev.disabled = num <= 1;
    elNext.disabled = num >= pdfDoc.numPages;

    renderFieldBoxes();
    renderFieldList();
  }

  // Boxes + live text on PDF
  function renderFieldBoxes(){
    overlay.innerHTML = "";

    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];
    for (const f of fields){
      const box = document.createElement("div");
      box.className = "field-box";
      box.dataset.id = f.id;

      const col = colorForId(f.id);
      box.style.borderColor = col;
      box.style.background = hexToRgba(col, 0.14);

      // Use percentages so it stays aligned even if canvas is CSS-scaled
      box.style.left   = (f.x * 100) + "%";
      box.style.top    = (f.y * 100) + "%";
      box.style.width  = (f.width * 100) + "%";
      box.style.height = (f.height * 100) + "%";

      // click selects (no label on box)
      box.title = (f.label || f.id); // hover shows label/id without clutter
      box.addEventListener("pointerdown", (ev)=>{
        ev.stopPropagation();
        setSelected(f.id);
        // focus inline editor for immediate typing
        const editor = box.querySelector(".field-editor");
        if (editor){
          editor.style.display = "block";
          editor.focus();
          // caret to end
          const v = editor.value;
          editor.setSelectionRange(v.length, v.length);
        }
      });

      // visible text overlay
      const text = document.createElement("div");
      text.className = "field-text";
      text.textContent = (fieldValues[f.id] || "");

      // inline editor (shown only when selected)
      const editor = document.createElement("textarea");
      editor.className = "field-editor";
      editor.value = fieldValues[f.id] || "";
      editor.addEventListener("input", ()=>{
        fieldValues[f.id] = editor.value;
        text.textContent = editor.value;        // live on PDF
        if (selectedFieldId === f.id) valueInput.value = editor.value; // keep side panel synced
      });
      editor.addEventListener("pointerdown", (e)=> e.stopPropagation()); // don't start drawing

      box.appendChild(text);
      box.appendChild(editor);

      if (f.id === selectedFieldId) box.classList.add("selected");

      overlay.appendChild(box);
    }

    // apply selected state after rebuild
    setSelected(selectedFieldId);
  }

  function renderFieldList(){
    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];

    fieldCountText.textContent = String(fields.length);

    fieldListEl.innerHTML = "";
    if (!fields.length){
      fieldListEl.innerHTML = `<div class="hint">No fields on this page. Drag on the PDF to create one.</div>`;
      return;
    }

    for (const f of fields){
      const item = document.createElement("div");
      item.className = "field-item";
      item.dataset.id = f.id;
      if (f.id === selectedFieldId) item.classList.add("selected");

      const col = colorForId(f.id);
      const label = f.label || "(no label)";
      item.innerHTML = `
        <div class="top">
          <div>
            <span class="swatch" style="background:${col}"></span>
            <b>${escapeHtml(label)}</b>
          </div>
          <small>${escapeHtml(f.id)}</small>
        </div>
      `;

      item.addEventListener("click", ()=>{
        setSelected(f.id);
        // scroll into view on the PDF if needed
        const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(f.id)}"]`);
        if (box) box.scrollIntoView({ block: "nearest", inline: "nearest" });
      });

      fieldListEl.appendChild(item);
    }
  }

  function hexToRgba(hex, a){
    const h = String(hex||"").replace("#","");
    if (h.length !== 6) return `rgba(255,255,255,${a})`;
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // Drawing: pointer events on overlay (not canvas)
  let drawing = false;
  let start = null;
  let tempBox = null;

  function overlayRect(){
    return overlay.getBoundingClientRect();
  }

  overlay.addEventListener("pointerdown", (e)=>{
    if (!pdfDoc) return;

    // if you clicked a box, it will stopPropagation and you won't get here
    setSelected(null);

    const r = overlayRect();
    const x = (e.clientX - r.left) / r.width;
    const y = (e.clientY - r.top) / r.height;

    drawing = true;
    start = { x: clamp01(x), y: clamp01(y) };

    tempBox = document.createElement("div");
    tempBox.className = "temp-box";
    tempBox.style.left = (start.x * 100) + "%";
    tempBox.style.top = (start.y * 100) + "%";
    tempBox.style.width = "0%";
    tempBox.style.height = "0%";
    overlay.appendChild(tempBox);

    overlay.setPointerCapture(e.pointerId);
  });

  overlay.addEventListener("pointermove", (e)=>{
    if (!drawing || !start || !tempBox) return;
    const r = overlayRect();
    const x = clamp01((e.clientX - r.left) / r.width);
    const y = clamp01((e.clientY - r.top) / r.height);

    const left = Math.min(start.x, x);
    const top  = Math.min(start.y, y);
    const w = Math.abs(x - start.x);
    const h = Math.abs(y - start.y);

    tempBox.style.left = (left * 100) + "%";
    tempBox.style.top  = (top * 100) + "%";
    tempBox.style.width  = (w * 100) + "%";
    tempBox.style.height = (h * 100) + "%";
  });

  overlay.addEventListener("pointerup", (e)=>{
    if (!drawing) return;
    drawing = false;

    if (!tempBox || !start) return;

    const left = parseFloat(tempBox.style.left) / 100;
    const top = parseFloat(tempBox.style.top) / 100;
    const width = parseFloat(tempBox.style.width) / 100;
    const height = parseFloat(tempBox.style.height) / 100;

    tempBox.remove();
    tempBox = null;

    // reject tiny boxes
    if (width < 0.01 || height < 0.01) return;

    const pageObj = getCurrentPageObj();
    const newId = `field_${currentPageNumber}_${pageObj.fields.length + 1}`;

    pageObj.fields.push({
      id: newId,
      label: "",
      x: left, y: top,
      width, height
    });

    fieldValues[newId] = "";

    rebuildColorMap();
    setSelected(newId);
    renderFieldBoxes();
    renderFieldList();

    // auto-focus the inline editor in the new box
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(newId)}"]`);
    const editor = box?.querySelector(".field-editor");
    if (editor){
      editor.style.display = "block";
      editor.focus();
    }
  });

  // Side panel wiring (keeps live PDF in sync)
  labelInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    const res = getFieldById(selectedFieldId);
    if (!res) return;
    res.field.label = labelInput.value;
    // update hover title
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    if (box) box.title = res.field.label || res.field.id;
    renderFieldList();
  });

  valueInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = valueInput.value;

    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    if (!box) return;

    const text = box.querySelector(".field-text");
    const editor = box.querySelector(".field-editor");
    if (text) text.textContent = valueInput.value;
    if (editor && editor !== document.activeElement) editor.value = valueInput.value;
  });

  deleteBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    removeField(selectedFieldId);
  });

  clearBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = "";
    valueInput.value = "";
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    if (box){
      const text = box.querySelector(".field-text");
      const editor = box.querySelector(".field-editor");
      if (text) text.textContent = "";
      if (editor) editor.value = "";
    }
  });

  // Keyboard delete
  document.addEventListener("keydown", (e)=>{
    const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
    const typing = (tag === "input" || tag === "textarea");
    if (typing) return;

    if ((e.key === "Delete" || e.key === "Backspace") && selectedFieldId){
      e.preventDefault();
      removeField(selectedFieldId);
    }
  });

  // Page buttons
  elPrev.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber <= 1) return;
    currentPageNumber--;
    setSelected(null);
    await renderPage(currentPageNumber);
  });

  elNext.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber >= pdfDoc.numPages) return;
    currentPageNumber++;
    setSelected(null);
    await renderPage(currentPageNumber);
  });

  // Load PDF
  elPdfFile.addEventListener("change", (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    loadedPdfName = file.name;
    elPdfNamePill.textContent = "PDF: " + loadedPdfName;

    const reader = new FileReader();
    reader.onload = async function(ev){
      originalPdfBytes = ev.target.result;

      const typedarray = new Uint8Array(originalPdfBytes);
      const loadingTask = pdfjsLib.getDocument({ data: typedarray });

      pdfDoc = await loadingTask.promise;
      currentPageNumber = 1;

      // reset mapping for simplicity (you can remove this if you want persistence)
      mapping.pages = [];
      for (const k of Object.keys(fieldValues)) delete fieldValues[k];
      selectedFieldId = null;

      rebuildColorMap();

      elDownloadPdf.disabled = false;
      elPageCount.textContent = String(pdfDoc.numPages);

      await renderPage(currentPageNumber);
    };
    reader.readAsArrayBuffer(file);
  });

  // Export filled PDF (flatten text into PDF)
  function safeBaseName(s){
    return (s || "filled_form").replace(/\.pdf$/i,"").replace(/[^\w\-]+/g,"_").slice(0,80) || "filled_form";
  }

  function wrapText(font, text, size, maxWidth){
    const words = String(text||"").replace(/\r/g,"").split(/\s+/).filter(Boolean);
    if (!words.length) return [];
    const lines = [];
    let line = words[0];

    for (let i=1;i<words.length;i++){
      const test = line + " " + words[i];
      const w = font.widthOfTextAtSize(test, size);
      if (w <= maxWidth) line = test;
      else { lines.push(line); line = words[i]; }
    }
    lines.push(line);
    return lines;
  }

  async function downloadFilledPdf(){
    if (!originalPdfBytes || !pdfDoc) { alert("Load a PDF first."); return; }

    const { PDFDocument, StandardFonts, rgb } = PDFLib;
    const pdf = await PDFDocument.load(originalPdfBytes);
    const pages = pdf.getPages();
    const font = await pdf.embedFont(StandardFonts.Helvetica);

    for (const pageMapping of mapping.pages){
      const pageIndex = pageMapping.pageNumber - 1;
      if (pageIndex < 0 || pageIndex >= pages.length) continue;

      const page = pages[pageIndex];
      const { width, height } = page.getSize();

      for (const f of (pageMapping.fields||[])){
        const val = (fieldValues[f.id] || "").trim();
        if (!val) continue;

        // Convert normalized (top-left based) to PDF coords (bottom-left origin)
        const boxX = f.x * width;
        const boxYFromTop = f.y * height;
        const boxW = f.width * width;
        const boxH = f.height * height;

        const margin = 2;
        const fontSize = 11;
        const lineGap = 2;

        const maxW = Math.max(10, boxW - margin*2);
        const paragraphs = String(fieldValues[f.id] || "").replace(/\r/g,"").split("\n");

        let lines = [];
        for (const para of paragraphs){
          if (!para.trim()){ lines.push(""); continue; }
          lines.push(...wrapText(font, para, fontSize, maxW));
        }

        const topY = height - boxYFromTop - margin;
        let y = topY - fontSize;
        const minY = height - (boxYFromTop + boxH) + margin;

        for (const line of lines){
          if (y < minY) break;
          page.drawText(line, {
            x: boxX + margin,
            y,
            size: fontSize,
            font,
            color: rgb(0,0,0),
            maxWidth: maxW
          });
          y -= (fontSize + lineGap);
        }
      }
    }

    const outBytes = await pdf.save();
    const blob = new Blob([outBytes], { type:"application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = safeBaseName(loadedPdfName) + "_filled.pdf";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  elDownloadPdf.addEventListener("click", ()=>{
    downloadFilledPdf().catch(err=>{
      console.error(err);
      alert("Failed to generate PDF. See console.");
    });
  });

</script>
</body>
</html>
