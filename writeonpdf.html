<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Write-On (drag box + live text + calibrate dot)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Same libs/versions -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; background:#f5f5f7; color:#111827; }
    header{
      position:sticky; top:0; z-index:50;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; background:#111827; color:#fff;
    }
    header input[type="file"]{ color:#e5e7eb; }
    header button{
      border:none; border-radius:10px; padding:8px 10px;
      font-weight:800; font-size:.85rem; cursor:pointer;
      background:#2563eb; color:#fff;
    }
    header button.secondary{ background:#374151; }
    header button.danger{ background:#dc2626; }
    header button:disabled{ opacity:.55; cursor:default; }
    .pill{
      display:inline-flex; align-items:center; gap:.45rem;
      padding:.25rem .65rem; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      font-size:.82rem; white-space:nowrap;
    }

    .wrap{ display:flex; gap:12px; padding:12px; align-items:flex-start; }
    @media (max-width: 980px){ .wrap{ flex-direction:column; } }

    .panel{
      background:#fff; border:1px solid #e5e7eb; border-radius:12px;
      box-shadow:0 1px 3px rgba(0,0,0,.06);
      padding:12px;
    }

    #pdfPanel{ flex:2; min-width:320px; }
    #sidePanel{ flex:1; min-width:280px; max-width:420px; position:sticky; top:62px; }
    @media (max-width: 980px){ #sidePanel{ position:static; max-width:none; } }

    .hint{ font-size:.85rem; color:#6b7280; line-height:1.35; }

    #pdfStage{
      position:relative; display:inline-block;
      max-width:100%;
      border-radius:10px; overflow:hidden;
      border:1px solid #e5e7eb;
      background:#111827;
      touch-action:none;
    }
    #pdfCanvas{
      display:block;
      max-width:100%;
      height:auto;
      background:#111827;
    }
    #overlay{ position:absolute; inset:0; }

    /* boxes (no labels) */
    .field-box{
      position:absolute; box-sizing:border-box;
      border:2px solid rgba(56,189,248,.95);
      background: rgba(56,189,248,.14);
      border-radius:8px;
      cursor:move;
      user-select:none;
    }
    .field-box.selected{
      border-color: rgba(34,197,94,.95) !important;
      background: rgba(34,197,94,.14) !important;
    }

    /* one text layer only: light gray */
    .field-text{
      position:absolute;
      left:2px; top:2px; right:2px; bottom:2px;
      font-size:14px;
      line-height:1.12;
      color: rgba(235,235,235,0.92);
      white-space: pre-wrap;
      overflow:hidden;
      pointer-events:none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.65);
      transform: translate(0px, 0px);
    }

    /* temp drawing box */
    .temp-box{
      position:absolute;
      box-sizing:border-box;
      border:2px dashed rgba(56,189,248,.95);
      background: rgba(56,189,248,.10);
      border-radius:8px;
      pointer-events:none;
    }

    /* calibration dot */
    #calDot{
      position:absolute;
      width:12px; height:12px;
      border-radius:999px;
      background: rgba(255,255,255,0.92);
      border:2px solid rgba(245,158,11,0.95);
      box-shadow: 0 2px 10px rgba(0,0,0,0.35);
      transform: translate(-50%, -50%);
      display:none;
      cursor:grab;
      z-index:100;
    }
    #calDot:active{ cursor:grabbing; }

    label{ display:block; font-size:.82rem; color:#374151; margin:10px 0 6px; }
    input[type="text"], textarea{
      width:100%; box-sizing:border-box;
      border:1px solid #d1d5db; border-radius:10px;
      padding:8px 10px; font-size:.92rem;
    }
    textarea{ min-height:140px; resize:vertical; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .row button{ padding:8px 10px; border-radius:10px; font-weight:800; }

    .field-list{
      margin-top:12px;
      border-top:1px solid #e5e7eb;
      padding-top:10px;
      max-height:260px;
      overflow:auto;
    }
    .field-item{
      border:1px solid #e5e7eb;
      border-radius:10px;
      padding:8px;
      margin-bottom:8px;
      background:#fff;
      cursor:pointer;
    }
    .field-item.selected{ border-color:#2563eb; background:#eff6ff; }
    .field-item .top{ display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .swatch{ width:10px; height:10px; border-radius:999px; border:1px solid rgba(0,0,0,.15); display:inline-block; margin-right:6px; vertical-align:middle; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color:#6b7280; font-size:.78rem; }
  </style>
</head>

<body>
<header>
  <input id="pdfFile" type="file" accept="application/pdf" />
  <button id="downloadPdf" class="secondary" disabled>Download filled PDF</button>

  <button id="toggleCal" class="secondary" disabled title="Show a dot you can drag to calibrate where text starts. Requires a selected field.">Calibrate dot</button>
  <button id="resetCal" class="secondary" disabled title="Reset calibration offset to 0,0">Reset</button>

  <span class="pill" id="pdfPill">PDF: (none)</span>
  <span class="pill">Page <span id="pageNum">–</span> / <span id="pageCount">–</span></span>
  <span class="pill" id="offsetPill">Offset: (0, 0)</span>

  <button id="prevBtn" class="secondary" disabled>Prev</button>
  <button id="nextBtn" class="secondary" disabled>Next</button>
</header>

<div class="wrap">
  <div id="pdfPanel" class="panel">
    <div class="hint" style="margin-bottom:10px;">
      Drag on empty space to create a box. Drag a box to move it. Click a box, then type on the right (text appears live on the PDF).
      Use <b>Calibrate dot</b> if the text start point needs a global nudge.
    </div>

    <div id="pdfStage">
      <canvas id="pdfCanvas"></canvas>
      <div id="overlay"></div>
      <div id="calDot" title="Drag to set text start offset"></div>
    </div>
  </div>

  <div id="sidePanel" class="panel">
    <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
      <h3 style="margin:0; font-size:1rem;">Selected Field</h3>
      <small id="selId" class="mono">(none)</small>
    </div>

    <div id="noSel" class="hint" style="margin-top:8px;">
      Nothing selected. Draw a box or click a box.
    </div>

    <div id="selUI" style="display:none;">
      <label>Label (only here; boxes stay clean)</label>
      <input id="labelInput" type="text" placeholder="e.g., Patient name" />

      <label>Value (shows live ON the PDF)</label>
      <textarea id="valueInput" placeholder="Type here…"></textarea>

      <div class="row">
        <button id="deleteBtn" class="danger">Delete field</button>
        <button id="clearBtn" class="secondary">Clear text</button>
      </div>
    </div>

    <div class="field-list">
      <div style="display:flex; justify-content:space-between; align-items:baseline;">
        <h3 style="margin:0; font-size:.95rem;">Fields on this page</h3>
        <small class="mono" id="fieldCountText">0</small>
      </div>
      <div id="fieldList" style="margin-top:8px;"></div>
    </div>
  </div>
</div>

<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";

  const COLOR_PALETTE = ["#dc2626","#eab308","#f97316","#2563eb","#16a34a","#9333ea","#06b6d4","#f43f5e"];

  const elPdfFile = document.getElementById("pdfFile");
  const elDownloadPdf = document.getElementById("downloadPdf");
  const elToggleCal = document.getElementById("toggleCal");
  const elResetCal = document.getElementById("resetCal");
  const elPrev = document.getElementById("prevBtn");
  const elNext = document.getElementById("nextBtn");
  const elPageNum = document.getElementById("pageNum");
  const elPageCount = document.getElementById("pageCount");
  const elPdfPill = document.getElementById("pdfPill");
  const elOffsetPill = document.getElementById("offsetPill");

  const pdfCanvas = document.getElementById("pdfCanvas");
  const ctx = pdfCanvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const calDot = document.getElementById("calDot");

  const selIdEl = document.getElementById("selId");
  const noSelEl = document.getElementById("noSel");
  const selUIEl = document.getElementById("selUI");
  const labelInput = document.getElementById("labelInput");
  const valueInput = document.getElementById("valueInput");
  const deleteBtn = document.getElementById("deleteBtn");
  const clearBtn = document.getElementById("clearBtn");

  const fieldListEl = document.getElementById("fieldList");
  const fieldCountText = document.getElementById("fieldCountText");

  let pdfDoc = null;                 // pdf.js doc
  let originalPdfBytes = null;       // ArrayBuffer
  let loadedPdfName = "";
  let currentPageNumber = 1;
  let scale = 1.25;

  // mapping: normalized to overlay (0..1, from top-left)
  const mapping = { pages: [] };
  const fieldValues = {};
  let selectedFieldId = null;
  let colorById = Object.create(null);

  // GLOBAL calibration offset in NORMALIZED units (so it survives resizing):
  // This is applied to where text starts inside every box.
  let textOffsetN = { dx: 0, dy: 0 };  // normalized (fraction of page)
  let calibrateMode = false;

  // ---------- helpers ----------
  function clamp01(n){ return Math.max(0, Math.min(1, n)); }
  function hexToRgba(hex, a){
    const h = String(hex||"").replace("#","");
    if (h.length !== 6) return `rgba(255,255,255,${a})`;
    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }
  function escapeHtml(s){
    return String(s||"")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
  }
  function safeBaseName(s){
    return (s || "filled_form").replace(/\.pdf$/i,"").replace(/[^\w\-]+/g,"_").slice(0,80) || "filled_form";
  }

  function getOrCreatePage(pageNumber){
    let p = mapping.pages.find(x => x.pageNumber === pageNumber);
    if (!p){
      p = { pageNumber, fields: [] };
      mapping.pages.push(p);
      mapping.pages.sort((a,b)=>a.pageNumber-b.pageNumber);
    }
    return p;
  }
  function getCurrentPageObj(){ return getOrCreatePage(currentPageNumber); }

  function getFieldById(fieldId){
    for (const p of mapping.pages){
      const f = (p.fields||[]).find(x => x.id === fieldId);
      if (f) return { page: p, field: f };
    }
    return null;
  }

  function rebuildColorMap(){
    colorById = Object.create(null);
    const pages = mapping.pages.slice().sort((a,b)=>a.pageNumber-b.pageNumber);
    let i = 0;
    for (const p of pages){
      for (const f of (p.fields||[])){
        colorById[f.id] = COLOR_PALETTE[i % COLOR_PALETTE.length];
        i++;
      }
    }
  }
  function colorForId(id){ return colorById[id] || COLOR_PALETTE[0]; }

  function getTextOffsetPx(){
    const w = overlay.clientWidth || 1;
    const h = overlay.clientHeight || 1;
    return { dx: textOffsetN.dx * w, dy: textOffsetN.dy * h };
  }
  function updateOffsetPill(){
    const p = getTextOffsetPx();
    elOffsetPill.textContent = `Offset: (${Math.round(p.dx)}, ${Math.round(p.dy)})`;
  }

  function setSelected(fieldId){
    selectedFieldId = fieldId || null;

    if (!selectedFieldId){
      selIdEl.textContent = "(none)";
      noSelEl.style.display = "block";
      selUIEl.style.display = "none";
    } else {
      const res = getFieldById(selectedFieldId);
      selIdEl.textContent = selectedFieldId;
      noSelEl.style.display = "none";
      selUIEl.style.display = "block";
      labelInput.value = res?.field?.label || "";
      valueInput.value = fieldValues[selectedFieldId] || "";
    }

    overlay.querySelectorAll(".field-box").forEach(box=>{
      box.classList.toggle("selected", box.dataset.id === selectedFieldId);
    });
    fieldListEl.querySelectorAll(".field-item").forEach(item=>{
      item.classList.toggle("selected", item.dataset.id === selectedFieldId);
    });

    // calibration dot needs a selected field
    if (calibrateMode) positionCalDot();
  }

  function removeField(fieldId){
    for (const p of mapping.pages){
      const idx = (p.fields||[]).findIndex(x => x.id === fieldId);
      if (idx !== -1){
        p.fields.splice(idx,1);
        delete fieldValues[fieldId];
        break;
      }
    }
    if (selectedFieldId === fieldId) setSelected(null);
    rebuildColorMap();
    renderFieldBoxes();
    renderFieldList();
  }

  // ---------- PDF render ----------
  async function renderPage(num){
    if (!pdfDoc) return;
    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({ scale });

    pdfCanvas.width = viewport.width;
    pdfCanvas.height = viewport.height;

    await page.render({ canvasContext: ctx, viewport }).promise;

    elPageNum.textContent = String(num);
    elPageCount.textContent = String(pdfDoc.numPages);
    elPrev.disabled = num <= 1;
    elNext.disabled = num >= pdfDoc.numPages;

    renderFieldBoxes();
    renderFieldList();
    updateOffsetPill();
    if (calibrateMode) positionCalDot();
  }

  // ---------- UI render ----------
  function renderFieldBoxes(){
    overlay.innerHTML = ""; // dot is separate element, not inside overlay

    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];
    const off = getTextOffsetPx();

    for (const f of fields){
      const box = document.createElement("div");
      box.className = "field-box";
      box.dataset.id = f.id;

      const col = colorForId(f.id);
      box.style.borderColor = col;
      box.style.background = hexToRgba(col, 0.14);

      box.style.left   = (f.x * 100) + "%";
      box.style.top    = (f.y * 100) + "%";
      box.style.width  = (f.width * 100) + "%";
      box.style.height = (f.height * 100) + "%";

      box.title = (f.label || f.id);

      const text = document.createElement("div");
      text.className = "field-text";
      text.textContent = (fieldValues[f.id] || "");
      text.style.transform = `translate(${off.dx}px, ${off.dy}px)`; // <-- calibrated nudge
      box.appendChild(text);

      box.addEventListener("pointerdown", startDragMoveBox);
      box.addEventListener("click", (ev)=>{ ev.stopPropagation(); setSelected(f.id); });

      overlay.appendChild(box);
    }

    setSelected(selectedFieldId);
  }

  function renderFieldList(){
    const pageObj = mapping.pages.find(p => p.pageNumber === currentPageNumber);
    const fields = pageObj?.fields || [];
    fieldCountText.textContent = String(fields.length);

    fieldListEl.innerHTML = "";
    if (!fields.length){
      fieldListEl.innerHTML = `<div class="hint">No fields on this page. Drag on empty space to create one.</div>`;
      return;
    }

    for (const f of fields){
      const item = document.createElement("div");
      item.className = "field-item";
      item.dataset.id = f.id;
      if (f.id === selectedFieldId) item.classList.add("selected");

      const col = colorForId(f.id);
      const label = f.label || "(no label)";
      item.innerHTML = `
        <div class="top">
          <div><span class="swatch" style="background:${col}"></span><b>${escapeHtml(label)}</b></div>
          <span class="mono">${escapeHtml(f.id)}</span>
        </div>
      `;
      item.addEventListener("click", ()=>{
        setSelected(f.id);
        const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(f.id)}"]`);
        if (box) box.scrollIntoView({ block:"nearest", inline:"nearest" });
      });
      fieldListEl.appendChild(item);
    }
  }

  // ---------- Create new box (drag on empty) ----------
  let drawing = false;
  let startPt = null;
  let tempBox = null;

  function overlayRect(){ return overlay.getBoundingClientRect(); }

  overlay.addEventListener("pointerdown", (e)=>{
    if (!pdfDoc) return;
    if (calibrateMode) return; // keep calibration simple: disable drawing while calibrating

    setSelected(null);

    const r = overlayRect();
    const x = clamp01((e.clientX - r.left) / r.width);
    const y = clamp01((e.clientY - r.top) / r.height);

    drawing = true;
    startPt = { x, y };

    tempBox = document.createElement("div");
    tempBox.className = "temp-box";
    tempBox.style.left = (x * 100) + "%";
    tempBox.style.top = (y * 100) + "%";
    tempBox.style.width = "0%";
    tempBox.style.height = "0%";
    overlay.appendChild(tempBox);

    overlay.setPointerCapture(e.pointerId);
  });

  overlay.addEventListener("pointermove", (e)=>{
    if (!drawing || !startPt || !tempBox) return;
    const r = overlayRect();
    const x = clamp01((e.clientX - r.left) / r.width);
    const y = clamp01((e.clientY - r.top) / r.height);

    const left = Math.min(startPt.x, x);
    const top  = Math.min(startPt.y, y);
    const w = Math.abs(x - startPt.x);
    const h = Math.abs(y - startPt.y);

    tempBox.style.left = (left * 100) + "%";
    tempBox.style.top  = (top * 100) + "%";
    tempBox.style.width  = (w * 100) + "%";
    tempBox.style.height = (h * 100) + "%";
  });

  overlay.addEventListener("pointerup", ()=>{
    if (!drawing) return;
    drawing = false;
    if (!tempBox || !startPt) return;

    const left = parseFloat(tempBox.style.left) / 100;
    const top = parseFloat(tempBox.style.top) / 100;
    const width = parseFloat(tempBox.style.width) / 100;
    const height = parseFloat(tempBox.style.height) / 100;

    tempBox.remove();
    tempBox = null;

    if (width < 0.01 || height < 0.01) return;

    const pageObj = getCurrentPageObj();
    const newId = `field_${currentPageNumber}_${pageObj.fields.length + 1}`;
    pageObj.fields.push({ id:newId, label:"", x:left, y:top, width, height });
    fieldValues[newId] = "";

    rebuildColorMap();
    setSelected(newId);
    renderFieldBoxes();
    renderFieldList();
  });

  // ---------- Drag existing box to move ----------
  let dragMove = null; // { id, startClientX, startClientY, startX, startY, w, h, rect }

  function startDragMoveBox(ev){
    if (calibrateMode) return;
    ev.stopPropagation();
    const id = ev.currentTarget.dataset.id;
    if (!id) return;

    setSelected(id);
    const res = getFieldById(id);
    if (!res) return;

    const r = overlayRect();
    dragMove = {
      id,
      startClientX: ev.clientX,
      startClientY: ev.clientY,
      startX: res.field.x,
      startY: res.field.y,
      w: res.field.width,
      h: res.field.height,
      rect: r
    };

    ev.currentTarget.setPointerCapture(ev.pointerId);
    ev.currentTarget.addEventListener("pointermove", onDragMoveBox);
    ev.currentTarget.addEventListener("pointerup", endDragMoveBox, { once:true });
    ev.currentTarget.addEventListener("pointercancel", endDragMoveBox, { once:true });
  }

  function onDragMoveBox(ev){
    if (!dragMove) return;
    const res = getFieldById(dragMove.id);
    if (!res) return;

    const dx = (ev.clientX - dragMove.startClientX) / dragMove.rect.width;
    const dy = (ev.clientY - dragMove.startClientY) / dragMove.rect.height;

    const newX = clamp01(dragMove.startX + dx);
    const newY = clamp01(dragMove.startY + dy);

    res.field.x = Math.max(0, Math.min(1 - dragMove.w, newX));
    res.field.y = Math.max(0, Math.min(1 - dragMove.h, newY));

    const boxEl = overlay.querySelector(`.field-box[data-id="${CSS.escape(dragMove.id)}"]`);
    if (boxEl){
      boxEl.style.left = (res.field.x * 100) + "%";
      boxEl.style.top  = (res.field.y * 100) + "%";
    }
    if (calibrateMode) positionCalDot();
  }

  function endDragMoveBox(ev){
    const boxEl = ev.currentTarget;
    boxEl.removeEventListener("pointermove", onDragMoveBox);
    dragMove = null;
    renderFieldList();
  }

  // ---------- Side panel: live updates ----------
  labelInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    const res = getFieldById(selectedFieldId);
    if (!res) return;
    res.field.label = labelInput.value;
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    if (box) box.title = res.field.label || res.field.id;
    renderFieldList();
  });

  valueInput.addEventListener("input", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = valueInput.value;
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    const text = box?.querySelector(".field-text");
    if (text) text.textContent = valueInput.value;
  });

  deleteBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    removeField(selectedFieldId);
    if (calibrateMode) hideCalDot();
  });

  clearBtn.addEventListener("click", ()=>{
    if (!selectedFieldId) return;
    fieldValues[selectedFieldId] = "";
    valueInput.value = "";
    const box = overlay.querySelector(`.field-box[data-id="${CSS.escape(selectedFieldId)}"]`);
    const text = box?.querySelector(".field-text");
    if (text) text.textContent = "";
  });

  // click empty overlay clears selection (unless calibrating)
  overlay.addEventListener("click", ()=>{
    if (calibrateMode) return;
    setSelected(null);
  });

  // keyboard delete (when not typing)
  document.addEventListener("keydown", (e)=>{
    const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
    const typing = (tag === "input" || tag === "textarea");
    if (typing) return;
    if ((e.key === "Delete" || e.key === "Backspace") && selectedFieldId){
      e.preventDefault();
      removeField(selectedFieldId);
      if (calibrateMode) hideCalDot();
    }
    if (e.key === "Escape" && calibrateMode){
      toggleCalibrate(false);
    }
  });

  // ---------- Page nav ----------
  elPrev.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber <= 1) return;
    currentPageNumber--;
    setSelected(null);
    hideCalDot();
    await renderPage(currentPageNumber);
  });

  elNext.addEventListener("click", async ()=>{
    if (!pdfDoc || currentPageNumber >= pdfDoc.numPages) return;
    currentPageNumber++;
    setSelected(null);
    hideCalDot();
    await renderPage(currentPageNumber);
  });

  // ---------- Load PDF ----------
  elPdfFile.addEventListener("change", (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    loadedPdfName = file.name;
    elPdfPill.textContent = "PDF: " + loadedPdfName;

    const reader = new FileReader();
    reader.onload = async (ev)=>{
      originalPdfBytes = ev.target.result;

      const typedarray = new Uint8Array(originalPdfBytes);
      pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
      currentPageNumber = 1;

      // reset (keep it simple)
      mapping.pages = [];
      for (const k of Object.keys(fieldValues)) delete fieldValues[k];
      selectedFieldId = null;

      textOffsetN = { dx: 0, dy: 0 };
      calibrateMode = false;
      hideCalDot();
      updateOffsetPill();

      rebuildColorMap();

      elDownloadPdf.disabled = false;
      elToggleCal.disabled = false;
      elResetCal.disabled = false;

      elPageCount.textContent = String(pdfDoc.numPages);
      await renderPage(currentPageNumber);
    };
    reader.readAsArrayBuffer(file);
  });

  // ---------- Calibration dot ----------
  function hideCalDot(){
    calDot.style.display = "none";
  }

  function positionCalDot(){
    if (!calibrateMode) { hideCalDot(); return; }
    if (!selectedFieldId) { hideCalDot(); return; }

    const res = getFieldById(selectedFieldId);
    if (!res) { hideCalDot(); return; }

    const w = overlay.clientWidth || 1;
    const h = overlay.clientHeight || 1;
    const marginPx = 2;

    // "text origin" inside the selected box (top-left + margin), plus current offset
    const originX = res.field.x * w + marginPx;
    const originY = res.field.y * h + marginPx;

    const off = getTextOffsetPx();
    const dotX = originX + off.dx;
    const dotY = originY + off.dy;

    calDot.style.left = dotX + "px";
    calDot.style.top = dotY + "px";
    calDot.style.display = "block";
  }

  function applyTextOffsetEverywhere(){
    const off = getTextOffsetPx();
    overlay.querySelectorAll(".field-text").forEach(t=>{
      t.style.transform = `translate(${off.dx}px, ${off.dy}px)`;
    });
    updateOffsetPill();
    if (calibrateMode) positionCalDot();
  }

  function toggleCalibrate(force){
    const newState = (typeof force === "boolean") ? force : !calibrateMode;

    if (newState){
      if (!selectedFieldId){
        alert("Select a field first, then turn on Calibrate dot.");
        return;
      }
      calibrateMode = true;
      calDot.style.display = "block";
      positionCalDot();
    } else {
      calibrateMode = false;
      hideCalDot();
    }
    // drawing boxes is disabled while calibrating (keeps it clean)
  }

  elToggleCal.addEventListener("click", ()=> toggleCalibrate());

  elResetCal.addEventListener("click", ()=>{
    textOffsetN = { dx: 0, dy: 0 };
    applyTextOffsetEverywhere();
  });

  // drag dot to set offset
  let dotDrag = null; // { startClientX, startClientY, startDxN, startDyN, originX, originY, w, h }

  calDot.addEventListener("pointerdown", (e)=>{
    if (!calibrateMode || !selectedFieldId) return;

    const res = getFieldById(selectedFieldId);
    if (!res) return;

    const w = overlay.clientWidth || 1;
    const h = overlay.clientHeight || 1;
    const marginPx = 2;

    const originX = res.field.x * w + marginPx;
    const originY = res.field.y * h + marginPx;

    dotDrag = {
      startClientX: e.clientX,
      startClientY: e.clientY,
      startDxN: textOffsetN.dx,
      startDyN: textOffsetN.dy,
      originX,
      originY,
      w, h
    };

    calDot.setPointerCapture(e.pointerId);
    calDot.addEventListener("pointermove", onDotMove);
    calDot.addEventListener("pointerup", onDotUp, { once:true });
    calDot.addEventListener("pointercancel", onDotUp, { once:true });
  });

  function onDotMove(e){
    if (!dotDrag) return;

    // compute new dot position in px from drag delta
    const dxPx = (e.clientX - dotDrag.startClientX);
    const dyPx = (e.clientY - dotDrag.startClientY);

    // convert px delta to normalized delta
    const dxN = dxPx / (dotDrag.w || 1);
    const dyN = dyPx / (dotDrag.h || 1);

    textOffsetN = {
      dx: dotDrag.startDxN + dxN,
      dy: dotDrag.startDyN + dyN
    };

    applyTextOffsetEverywhere();
  }

  function onDotUp(e){
    calDot.removeEventListener("pointermove", onDotMove);
    dotDrag = null;
  }

  // ---------- Export to PDF (FIXED mapping via pdf.js viewport.convertToPdfPoint) ----------
  function wrapText(font, text, size, maxWidth){
    const words = String(text||"").replace(/\r/g,"").split(/\s+/).filter(Boolean);
    if (!words.length) return [];
    const lines = [];
    let line = words[0];
    for (let i=1;i<words.length;i++){
      const test = line + " " + words[i];
      const w = font.widthOfTextAtSize(test, size);
      if (w <= maxWidth) line = test;
      else { lines.push(line); line = words[i]; }
    }
    lines.push(line);
    return lines;
  }

  async function downloadFilledPdf(){
    if (!originalPdfBytes || !pdfDoc) { alert("Load a PDF first."); return; }
    if (typeof PDFLib === "undefined") { alert("pdf-lib did not load."); return; }

    const { PDFDocument, StandardFonts, rgb } = PDFLib;
    const out = await PDFDocument.load(originalPdfBytes);
    const outPages = out.getPages();
    const font = await out.embedFont(StandardFonts.Helvetica);

    // For each mapped page, use pdf.js viewport conversion at scale=1 for correct PDF-space mapping
    for (const pageMapping of mapping.pages){
      const pageIndex = pageMapping.pageNumber - 1;
      if (pageIndex < 0 || pageIndex >= outPages.length) continue;

      const outPage = outPages[pageIndex];

      // pdf.js page + viewport
      const jsPage = await pdfDoc.getPage(pageMapping.pageNumber);
      const vp = jsPage.getViewport({ scale: 1 });

      // Convert calibration offset (normalized) into PDF points using convertToPdfPoint deltas
      const dxPx1 = textOffsetN.dx * vp.width;
      const dyPx1 = textOffsetN.dy * vp.height;
      const p0 = vp.convertToPdfPoint(0, 0);
      const p1 = vp.convertToPdfPoint(dxPx1, dyPx1);
      const dxPt = p1[0] - p0[0];
      const dyPt = p1[1] - p0[1];

      for (const f of (pageMapping.fields||[])){
        const value = String(fieldValues[f.id] || "");
        if (!value.trim()) continue;

        // Box corners in viewport pixels at scale=1
        const leftPx = f.x * vp.width;
        const topPx  = f.y * vp.height;
        const wPx    = f.width * vp.width;
        const hPx    = f.height * vp.height;

        // Convert to PDF points (accounts for cropbox/rotation)
        const tl = vp.convertToPdfPoint(leftPx, topPx);
        const br = vp.convertToPdfPoint(leftPx + wPx, topPx + hPx);

        const boxX = Math.min(tl[0], br[0]);
        const boxY = Math.min(tl[1], br[1]);
        const boxW = Math.abs(br[0] - tl[0]);
        const boxH = Math.abs(br[1] - tl[1]);

        const margin = 2;
        const fontSize = 11;
        const lineGap = 2;
        const maxW = Math.max(10, boxW - margin*2);

        // wrap paragraphs
        const paras = value.replace(/\r/g,"").split("\n");
        let lines = [];
        for (const para of paras){
          if (!para.trim()) { lines.push(""); continue; }
          lines.push(...wrapText(font, para, fontSize, maxW));
        }

        // Place text from top-left of box (PDF coords are bottom-left), plus calibration offset in PDF points
        const textX = boxX + margin + dxPt;
        const topY = boxY + boxH - margin + dyPt;
        let y = topY - fontSize;

        // bottom guard (stays inside box)
        const bottomLimit = boxY + margin + dyPt;

        for (const line of lines){
          if (y < bottomLimit) break;
          outPage.drawText(line, {
            x: textX,
            y,
            size: fontSize,
            font,
            color: rgb(0,0,0),
            maxWidth: maxW
          });
          y -= (fontSize + lineGap);
        }
      }
    }

    const bytes = await out.save();
    const blob = new Blob([bytes], { type:"application/pdf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = safeBaseName(loadedPdfName) + "_filled.pdf";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  elDownloadPdf.addEventListener("click", ()=>{
    downloadFilledPdf().catch(err=>{
      console.error(err);
      alert("Failed to generate PDF. See console.");
    });
  });

  // enable/disable cal button based on selection
  function refreshCalButtons(){
    elToggleCal.disabled = !pdfDoc;
    elResetCal.disabled = !pdfDoc;
  }
  refreshCalButtons();

  // keep dot positioned correctly on resize
  window.addEventListener("resize", ()=>{
    applyTextOffsetEverywhere();
  });

  // when selection changes, keep cal dot correct
  const _setSelected = setSelected;
  setSelected = function(fieldId){
    _setSelected(fieldId);
    if (calibrateMode) positionCalDot();
  };

  // initial pill
  updateOffsetPill();
</script>
</body>
</html>
